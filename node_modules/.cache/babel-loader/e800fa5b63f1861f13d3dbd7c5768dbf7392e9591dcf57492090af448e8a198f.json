{"ast":null,"code":"var _jsxFileName = \"/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/CosmicVortex.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VortexContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 0;\n  pointer-events: none;\n  background: transparent;\n`;\n\n// Aurora shader\n_c = VortexContainer;\nconst auroraVertexShader = `\n  varying vec2 vUv;\n  varying float vElevation;\n  uniform float time;\n\n  void main() {\n    vUv = uv;\n    \n    // Create flowing movement\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    float elevation = sin(modelPosition.x * 2.0 + time * 0.5) *\n                     sin(modelPosition.y * 2.0 + time * 0.3) * 0.2;\n    \n    // Add forward motion\n    modelPosition.z += elevation - time * 2.0;\n    vElevation = elevation;\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n  }\n`;\nconst auroraFragmentShader = `\n  uniform float time;\n  uniform vec3 colorA;\n  uniform vec3 colorB;\n  uniform vec3 colorC;\n  varying vec2 vUv;\n  varying float vElevation;\n\n  void main() {\n    float mixStrength = (vElevation + 0.2) * 0.5;\n    \n    // Create swirling effect\n    vec2 swirl = vUv - 0.5;\n    float r = length(swirl) * 2.0;\n    float theta = atan(swirl.y, swirl.x);\n    float spiral = sin(r * 10.0 - time * 0.5 + theta * 2.0);\n    \n    // Mix colors based on position and time\n    vec3 color1 = mix(colorA, colorB, mixStrength);\n    vec3 color2 = mix(colorB, colorC, mixStrength);\n    vec3 finalColor = mix(color1, color2, spiral * 0.5 + 0.5);\n    \n    // Add transparency for ethereal effect\n    float alpha = smoothstep(0.0, 0.5, mixStrength) * 0.6;\n    \n    gl_FragColor = vec4(finalColor, alpha);\n  }\n`;\nexport const CosmicVortex = () => {\n  _s();\n  const containerRef = useRef(null);\n  const rendererRef = useRef(null);\n  const particlesRef = useRef(null);\n  const particlePositionsRef = useRef(null);\n  const particleSpeedsRef = useRef(null);\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color('#000000');\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.z = 5;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      alpha: false,\n      powerPreference: 'default',\n      preserveDrawingBuffer: true\n    });\n    renderer.setClearColor('#000000', 1);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Aurora planes\n    const createAuroraPlane = (position, rotation, colors) => {\n      const geometry = new THREE.PlaneGeometry(30, 30, 32, 32);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: auroraVertexShader,\n        fragmentShader: auroraFragmentShader,\n        uniforms: {\n          time: {\n            value: 0\n          },\n          colorA: {\n            value: new THREE.Color(colors[0])\n          },\n          colorB: {\n            value: new THREE.Color(colors[1])\n          },\n          colorC: {\n            value: new THREE.Color(colors[2])\n          }\n        },\n        transparent: true,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n        blending: THREE.AdditiveBlending\n      });\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.rotation.copy(rotation);\n      return mesh;\n    };\n\n    // Create tunnel of aurora planes\n    const auroras = [createAuroraPlane(new THREE.Vector3(0, 0, -10), new THREE.Euler(0, 0, 0), ['#00ff88', '#0088ff', '#8800ff']), createAuroraPlane(new THREE.Vector3(0, 0, -20), new THREE.Euler(0, Math.PI * 0.25, 0), ['#00ccff', '#ffcc00', '#00ffcc']), createAuroraPlane(new THREE.Vector3(0, 0, -30), new THREE.Euler(0, Math.PI * 0.5, 0), ['#ffcc00', '#00ccff', '#cc00ff'])];\n    auroras.forEach(aurora => scene.add(aurora));\n\n    // Particles\n    const particlesGeometry = new THREE.BufferGeometry();\n    const particlesCount = 3000;\n    const positions = new Float32Array(particlesCount * 3);\n    const colors = new Float32Array(particlesCount * 3);\n    const speeds = new Float32Array(particlesCount);\n    const generateParticle = index => {\n      const i3 = index * 3;\n      const angle = Math.random() * Math.PI * 2;\n      const radius = Math.random() * 15 + 5; // Spread particles in a ring\n      const zPos = Math.random() * 100 - 50; // Spread along z-axis\n\n      positions[i3] = Math.cos(angle) * radius;\n      positions[i3 + 1] = Math.sin(angle) * radius;\n      positions[i3 + 2] = zPos;\n      speeds[index] = Math.random() * 0.2 + 0.1; // Random speed for each particle\n\n      // Color gradient based on distance from center\n      const distanceRatio = radius / 20;\n      if (distanceRatio < 0.33) {\n        colors[i3] = 0.0; // Blue\n        colors[i3 + 1] = 0.5 + Math.random() * 0.5;\n        colors[i3 + 2] = 1.0;\n      } else if (distanceRatio < 0.66) {\n        colors[i3] = 0.0; // Green\n        colors[i3 + 1] = 1.0;\n        colors[i3 + 2] = 0.5 + Math.random() * 0.5;\n      } else {\n        colors[i3] = 1.0; // Yellow\n        colors[i3 + 1] = 1.0;\n        colors[i3 + 2] = 0.0;\n      }\n    };\n    for (let i = 0; i < particlesCount; i++) {\n      generateParticle(i);\n    }\n    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n    const particlesMaterial = new THREE.PointsMaterial({\n      size: 0.03,\n      vertexColors: true,\n      transparent: true,\n      opacity: 0.8,\n      blending: THREE.AdditiveBlending,\n      sizeAttenuation: true,\n      depthWrite: false\n    });\n    const particles = new THREE.Points(particlesGeometry, particlesMaterial);\n    particlesRef.current = particles;\n    particlePositionsRef.current = positions;\n    particleSpeedsRef.current = speeds;\n    scene.add(particles);\n\n    // Animation\n    let time = 0;\n    const animate = () => {\n      requestAnimationFrame(animate);\n      time += 0.01;\n\n      // Update aurora uniforms\n      auroras.forEach(aurora => {\n        const material = aurora.material;\n        material.uniforms.time.value = time;\n        aurora.position.z += 0.05;\n        if (aurora.position.z > 5) {\n          aurora.position.z = -30;\n        }\n      });\n\n      // Update particles\n      if (particlePositionsRef.current && particleSpeedsRef.current) {\n        const positions = particlePositionsRef.current;\n        const speeds = particleSpeedsRef.current;\n        for (let i = 0; i < particlesCount; i++) {\n          const i3 = i * 3;\n          positions[i3 + 2] += speeds[i];\n\n          // Reset particle when it goes too far\n          if (positions[i3 + 2] > 5) {\n            positions[i3 + 2] = -50;\n            const angle = Math.random() * Math.PI * 2;\n            const radius = Math.random() * 15 + 5;\n            positions[i3] = Math.cos(angle) * radius;\n            positions[i3 + 1] = Math.sin(angle) * radius;\n          }\n        }\n        particlesGeometry.attributes.position.needsUpdate = true;\n      }\n      renderer.render(scene, camera);\n    };\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n    window.addEventListener('resize', handleResize);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      renderer.dispose();\n      if (containerRef.current) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(VortexContainer, {\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 262,\n    columnNumber: 10\n  }, this);\n};\n_s(CosmicVortex, \"UYwnUWtBh3h15EVjjO7ZfRu9l60=\");\n_c2 = CosmicVortex;\nvar _c, _c2;\n$RefreshReg$(_c, \"VortexContainer\");\n$RefreshReg$(_c2, \"CosmicVortex\");","map":{"version":3,"names":["React","useEffect","useRef","styled","THREE","jsxDEV","_jsxDEV","VortexContainer","div","_c","auroraVertexShader","auroraFragmentShader","CosmicVortex","_s","containerRef","rendererRef","particlesRef","particlePositionsRef","particleSpeedsRef","current","scene","Scene","background","Color","camera","PerspectiveCamera","window","innerWidth","innerHeight","position","z","renderer","WebGLRenderer","antialias","alpha","powerPreference","preserveDrawingBuffer","setClearColor","setSize","setPixelRatio","Math","min","devicePixelRatio","appendChild","domElement","createAuroraPlane","rotation","colors","geometry","PlaneGeometry","material","ShaderMaterial","vertexShader","fragmentShader","uniforms","time","value","colorA","colorB","colorC","transparent","depthWrite","side","DoubleSide","blending","AdditiveBlending","mesh","Mesh","copy","auroras","Vector3","Euler","PI","forEach","aurora","add","particlesGeometry","BufferGeometry","particlesCount","positions","Float32Array","speeds","generateParticle","index","i3","angle","random","radius","zPos","cos","sin","distanceRatio","i","setAttribute","BufferAttribute","particlesMaterial","PointsMaterial","size","vertexColors","opacity","sizeAttenuation","particles","Points","animate","requestAnimationFrame","attributes","needsUpdate","render","handleResize","aspect","updateProjectionMatrix","addEventListener","removeEventListener","dispose","removeChild","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/CosmicVortex.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\n\nconst VortexContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 0;\n  pointer-events: none;\n  background: transparent;\n`;\n\n// Aurora shader\nconst auroraVertexShader = `\n  varying vec2 vUv;\n  varying float vElevation;\n  uniform float time;\n\n  void main() {\n    vUv = uv;\n    \n    // Create flowing movement\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    float elevation = sin(modelPosition.x * 2.0 + time * 0.5) *\n                     sin(modelPosition.y * 2.0 + time * 0.3) * 0.2;\n    \n    // Add forward motion\n    modelPosition.z += elevation - time * 2.0;\n    vElevation = elevation;\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n  }\n`;\n\nconst auroraFragmentShader = `\n  uniform float time;\n  uniform vec3 colorA;\n  uniform vec3 colorB;\n  uniform vec3 colorC;\n  varying vec2 vUv;\n  varying float vElevation;\n\n  void main() {\n    float mixStrength = (vElevation + 0.2) * 0.5;\n    \n    // Create swirling effect\n    vec2 swirl = vUv - 0.5;\n    float r = length(swirl) * 2.0;\n    float theta = atan(swirl.y, swirl.x);\n    float spiral = sin(r * 10.0 - time * 0.5 + theta * 2.0);\n    \n    // Mix colors based on position and time\n    vec3 color1 = mix(colorA, colorB, mixStrength);\n    vec3 color2 = mix(colorB, colorC, mixStrength);\n    vec3 finalColor = mix(color1, color2, spiral * 0.5 + 0.5);\n    \n    // Add transparency for ethereal effect\n    float alpha = smoothstep(0.0, 0.5, mixStrength) * 0.6;\n    \n    gl_FragColor = vec4(finalColor, alpha);\n  }\n`;\n\nexport const CosmicVortex: React.FC = () => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const particlesRef = useRef<THREE.Points | null>(null);\n  const particlePositionsRef = useRef<Float32Array | null>(null);\n  const particleSpeedsRef = useRef<Float32Array | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color('#000000');\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.z = 5;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({ \n      antialias: true, \n      alpha: false,\n      powerPreference: 'default',\n      preserveDrawingBuffer: true,\n    });\n    renderer.setClearColor('#000000', 1);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Aurora planes\n    const createAuroraPlane = (position: THREE.Vector3, rotation: THREE.Euler, colors: [string, string, string]) => {\n      const geometry = new THREE.PlaneGeometry(30, 30, 32, 32);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: auroraVertexShader,\n        fragmentShader: auroraFragmentShader,\n        uniforms: {\n          time: { value: 0 },\n          colorA: { value: new THREE.Color(colors[0]) },\n          colorB: { value: new THREE.Color(colors[1]) },\n          colorC: { value: new THREE.Color(colors[2]) }\n        },\n        transparent: true,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n        blending: THREE.AdditiveBlending\n      });\n\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.rotation.copy(rotation);\n      return mesh;\n    };\n\n    // Create tunnel of aurora planes\n    const auroras = [\n      createAuroraPlane(\n        new THREE.Vector3(0, 0, -10),\n        new THREE.Euler(0, 0, 0),\n        ['#00ff88', '#0088ff', '#8800ff']\n      ),\n      createAuroraPlane(\n        new THREE.Vector3(0, 0, -20),\n        new THREE.Euler(0, Math.PI * 0.25, 0),\n        ['#00ccff', '#ffcc00', '#00ffcc']\n      ),\n      createAuroraPlane(\n        new THREE.Vector3(0, 0, -30),\n        new THREE.Euler(0, Math.PI * 0.5, 0),\n        ['#ffcc00', '#00ccff', '#cc00ff']\n      )\n    ];\n\n    auroras.forEach(aurora => scene.add(aurora));\n\n    // Particles\n    const particlesGeometry = new THREE.BufferGeometry();\n    const particlesCount = 3000;\n    const positions = new Float32Array(particlesCount * 3);\n    const colors = new Float32Array(particlesCount * 3);\n    const speeds = new Float32Array(particlesCount);\n\n    const generateParticle = (index: number) => {\n      const i3 = index * 3;\n      const angle = Math.random() * Math.PI * 2;\n      const radius = Math.random() * 15 + 5; // Spread particles in a ring\n      const zPos = Math.random() * 100 - 50; // Spread along z-axis\n\n      positions[i3] = Math.cos(angle) * radius;\n      positions[i3 + 1] = Math.sin(angle) * radius;\n      positions[i3 + 2] = zPos;\n\n      speeds[index] = Math.random() * 0.2 + 0.1; // Random speed for each particle\n\n      // Color gradient based on distance from center\n      const distanceRatio = radius / 20;\n      if (distanceRatio < 0.33) {\n        colors[i3] = 0.0; // Blue\n        colors[i3 + 1] = 0.5 + Math.random() * 0.5;\n        colors[i3 + 2] = 1.0;\n      } else if (distanceRatio < 0.66) {\n        colors[i3] = 0.0; // Green\n        colors[i3 + 1] = 1.0;\n        colors[i3 + 2] = 0.5 + Math.random() * 0.5;\n      } else {\n        colors[i3] = 1.0; // Yellow\n        colors[i3 + 1] = 1.0;\n        colors[i3 + 2] = 0.0;\n      }\n    };\n\n    for (let i = 0; i < particlesCount; i++) {\n      generateParticle(i);\n    }\n\n    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n    const particlesMaterial = new THREE.PointsMaterial({\n      size: 0.03,\n      vertexColors: true,\n      transparent: true,\n      opacity: 0.8,\n      blending: THREE.AdditiveBlending,\n      sizeAttenuation: true,\n      depthWrite: false\n    });\n\n    const particles = new THREE.Points(particlesGeometry, particlesMaterial);\n    particlesRef.current = particles;\n    particlePositionsRef.current = positions;\n    particleSpeedsRef.current = speeds;\n    scene.add(particles);\n\n    // Animation\n    let time = 0;\n    const animate = () => {\n      requestAnimationFrame(animate);\n\n      time += 0.01;\n\n      // Update aurora uniforms\n      auroras.forEach((aurora) => {\n        const material = aurora.material as THREE.ShaderMaterial;\n        material.uniforms.time.value = time;\n        aurora.position.z += 0.05;\n        if (aurora.position.z > 5) {\n          aurora.position.z = -30;\n        }\n      });\n\n      // Update particles\n      if (particlePositionsRef.current && particleSpeedsRef.current) {\n        const positions = particlePositionsRef.current;\n        const speeds = particleSpeedsRef.current;\n\n        for (let i = 0; i < particlesCount; i++) {\n          const i3 = i * 3;\n          positions[i3 + 2] += speeds[i];\n\n          // Reset particle when it goes too far\n          if (positions[i3 + 2] > 5) {\n            positions[i3 + 2] = -50;\n            const angle = Math.random() * Math.PI * 2;\n            const radius = Math.random() * 15 + 5;\n            positions[i3] = Math.cos(angle) * radius;\n            positions[i3 + 1] = Math.sin(angle) * radius;\n          }\n        }\n\n        particlesGeometry.attributes.position.needsUpdate = true;\n      }\n\n      renderer.render(scene, camera);\n    };\n\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      renderer.dispose();\n      if (containerRef.current) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n\n  return <VortexContainer ref={containerRef} />;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}