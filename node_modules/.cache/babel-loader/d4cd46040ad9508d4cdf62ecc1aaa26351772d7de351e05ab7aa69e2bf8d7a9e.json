{"ast":null,"code":"var _jsxFileName = \"/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/CosmicVortex.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VortexContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 0;\n  pointer-events: none;\n  background: transparent;\n`;\n\n// Aurora shader\n_c = VortexContainer;\nconst auroraVertexShader = `\n  varying vec2 vUv;\n  varying float vElevation;\n  uniform float time;\n\n  void main() {\n    vUv = uv;\n    \n    // Create flowing movement\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    float elevation = sin(modelPosition.x * 2.0 + time * 0.5) *\n                     sin(modelPosition.y * 2.0 + time * 0.3) * 0.1;\n    \n    modelPosition.z += elevation - time * 2.0;\n    vElevation = elevation;\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n  }\n`;\nconst auroraFragmentShader = `\n  uniform float time;\n  uniform vec3 colorA;\n  uniform vec3 colorB;\n  uniform vec3 colorC;\n  varying vec2 vUv;\n  varying float vElevation;\n\n  void main() {\n    float mixStrength = (vElevation + 0.2) * 0.5;\n    \n    // Create tunnel effect\n    vec2 centeredUv = vUv - 0.5;\n    float distanceFromCenter = length(centeredUv);\n    float tunnelEffect = smoothstep(0.0, 0.5, distanceFromCenter);\n    \n    // Create swirling effect\n    float theta = atan(centeredUv.y, centeredUv.x);\n    float spiral = sin(distanceFromCenter * 20.0 - time * 0.5 + theta * 4.0);\n    \n    // Mix colors based on position and time\n    vec3 color1 = mix(colorA, colorB, tunnelEffect);\n    vec3 color2 = mix(colorB, colorC, mixStrength);\n    vec3 finalColor = mix(color1, color2, spiral * 0.5 + 0.5);\n    \n    // Add transparency for ethereal effect\n    float alpha = (1.0 - tunnelEffect) * 0.6;\n    \n    gl_FragColor = vec4(finalColor, alpha);\n  }\n`;\nexport const CosmicVortex = () => {\n  _s();\n  const containerRef = useRef(null);\n  const rendererRef = useRef(null);\n  const particlesRef = useRef(null);\n  const particlePositionsRef = useRef(null);\n  const particleSpeedsRef = useRef(null);\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color('#000000');\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.z = 5;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      alpha: false,\n      powerPreference: 'default',\n      preserveDrawingBuffer: true\n    });\n    renderer.setClearColor('#000000', 1);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Aurora planes\n    const createAuroraPlane = (position, rotation, colors) => {\n      const geometry = new THREE.PlaneGeometry(30, 30, 32, 32);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: auroraVertexShader,\n        fragmentShader: auroraFragmentShader,\n        uniforms: {\n          time: {\n            value: 0\n          },\n          colorA: {\n            value: new THREE.Color(colors[0])\n          },\n          colorB: {\n            value: new THREE.Color(colors[1])\n          },\n          colorC: {\n            value: new THREE.Color(colors[2])\n          }\n        },\n        transparent: true,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n        blending: THREE.AdditiveBlending\n      });\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.rotation.copy(rotation);\n      return mesh;\n    };\n\n    // Create tunnel of aurora planes\n    const numPlanes = 8;\n    const radius = 15;\n    const auroras = [];\n    for (let i = 0; i < numPlanes; i++) {\n      const angle = i / numPlanes * Math.PI * 2;\n      const x = Math.cos(angle) * radius;\n      const y = Math.sin(angle) * radius;\n\n      // Create a plane facing the center\n      const position = new THREE.Vector3(x, y, -30);\n      const rotation = new THREE.Euler(0, -angle, 0);\n      const colors = [i % 2 === 0 ? '#00ff88' : '#0088ff', i % 3 === 0 ? '#8800ff' : '#00ccff', i % 2 === 0 ? '#ffcc00' : '#cc00ff'];\n      const aurora = createAuroraPlane(position, rotation, colors);\n      auroras.push(aurora);\n      scene.add(aurora);\n    }\n\n    // Particles\n    const particlesGeometry = new THREE.BufferGeometry();\n    const particlesCount = 3000;\n    const positions = new Float32Array(particlesCount * 3);\n    const colors = new Float32Array(particlesCount * 3);\n    const speeds = new Float32Array(particlesCount);\n    const generateParticle = index => {\n      const i3 = index * 3;\n      const angle = Math.random() * Math.PI * 2;\n      const radius = Math.random() * 15 + 5; // Spread particles in a ring\n      const zPos = Math.random() * 100 - 50; // Spread along z-axis\n\n      positions[i3] = Math.cos(angle) * radius;\n      positions[i3 + 1] = Math.sin(angle) * radius;\n      positions[i3 + 2] = zPos;\n      speeds[index] = Math.random() * 0.2 + 0.1; // Random speed for each particle\n\n      // Color gradient based on distance from center\n      const distanceRatio = radius / 20;\n      if (distanceRatio < 0.33) {\n        colors[i3] = 0.0; // Blue\n        colors[i3 + 1] = 0.5 + Math.random() * 0.5;\n        colors[i3 + 2] = 1.0;\n      } else if (distanceRatio < 0.66) {\n        colors[i3] = 0.0; // Green\n        colors[i3 + 1] = 1.0;\n        colors[i3 + 2] = 0.5 + Math.random() * 0.5;\n      } else {\n        colors[i3] = 1.0; // Yellow\n        colors[i3 + 1] = 1.0;\n        colors[i3 + 2] = 0.0;\n      }\n    };\n    for (let i = 0; i < particlesCount; i++) {\n      generateParticle(i);\n    }\n    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n    const particlesMaterial = new THREE.PointsMaterial({\n      size: 0.03,\n      vertexColors: true,\n      transparent: true,\n      opacity: 0.8,\n      blending: THREE.AdditiveBlending,\n      sizeAttenuation: true,\n      depthWrite: false\n    });\n    const particles = new THREE.Points(particlesGeometry, particlesMaterial);\n    particlesRef.current = particles;\n    particlePositionsRef.current = positions;\n    particleSpeedsRef.current = speeds;\n    scene.add(particles);\n\n    // Animation\n    let time = 0;\n    const animate = () => {\n      requestAnimationFrame(animate);\n      time += 0.01;\n\n      // Update aurora uniforms\n      auroras.forEach((aurora, index) => {\n        const material = aurora.material;\n        material.uniforms.time.value = time;\n\n        // Move forward and rotate slightly\n        aurora.position.z += 0.05;\n        if (aurora.position.z > 5) {\n          aurora.position.z = -30;\n        }\n\n        // Add slight rotation to the tunnel\n        const angle = index / auroras.length * Math.PI * 2 + time * 0.05;\n        const x = Math.cos(angle) * radius;\n        const y = Math.sin(angle) * radius;\n        aurora.position.x = x;\n        aurora.position.y = y;\n        aurora.rotation.y = -angle;\n      });\n\n      // Update particles\n      if (particlePositionsRef.current && particleSpeedsRef.current) {\n        const positions = particlePositionsRef.current;\n        const speeds = particleSpeedsRef.current;\n        for (let i = 0; i < particlesCount; i++) {\n          const i3 = i * 3;\n          positions[i3 + 2] += speeds[i];\n\n          // Reset particle when it goes too far\n          if (positions[i3 + 2] > 5) {\n            positions[i3 + 2] = -50;\n            const angle = Math.random() * Math.PI * 2;\n            const radius = Math.random() * 15 + 5;\n            positions[i3] = Math.cos(angle) * radius;\n            positions[i3 + 1] = Math.sin(angle) * radius;\n          }\n        }\n        particlesGeometry.attributes.position.needsUpdate = true;\n      }\n      renderer.render(scene, camera);\n    };\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n    window.addEventListener('resize', handleResize);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      renderer.dispose();\n      if (containerRef.current) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(VortexContainer, {\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 278,\n    columnNumber: 10\n  }, this);\n};\n_s(CosmicVortex, \"UYwnUWtBh3h15EVjjO7ZfRu9l60=\");\n_c2 = CosmicVortex;\nvar _c, _c2;\n$RefreshReg$(_c, \"VortexContainer\");\n$RefreshReg$(_c2, \"CosmicVortex\");","map":{"version":3,"names":["React","useEffect","useRef","styled","THREE","jsxDEV","_jsxDEV","VortexContainer","div","_c","auroraVertexShader","auroraFragmentShader","CosmicVortex","_s","containerRef","rendererRef","particlesRef","particlePositionsRef","particleSpeedsRef","current","scene","Scene","background","Color","camera","PerspectiveCamera","window","innerWidth","innerHeight","position","z","renderer","WebGLRenderer","antialias","alpha","powerPreference","preserveDrawingBuffer","setClearColor","setSize","setPixelRatio","Math","min","devicePixelRatio","appendChild","domElement","createAuroraPlane","rotation","colors","geometry","PlaneGeometry","material","ShaderMaterial","vertexShader","fragmentShader","uniforms","time","value","colorA","colorB","colorC","transparent","depthWrite","side","DoubleSide","blending","AdditiveBlending","mesh","Mesh","copy","numPlanes","radius","auroras","i","angle","PI","x","cos","y","sin","Vector3","Euler","aurora","push","add","particlesGeometry","BufferGeometry","particlesCount","positions","Float32Array","speeds","generateParticle","index","i3","random","zPos","distanceRatio","setAttribute","BufferAttribute","particlesMaterial","PointsMaterial","size","vertexColors","opacity","sizeAttenuation","particles","Points","animate","requestAnimationFrame","forEach","length","attributes","needsUpdate","render","handleResize","aspect","updateProjectionMatrix","addEventListener","removeEventListener","dispose","removeChild","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/CosmicVortex.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\n\nconst VortexContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 0;\n  pointer-events: none;\n  background: transparent;\n`;\n\n// Aurora shader\nconst auroraVertexShader = `\n  varying vec2 vUv;\n  varying float vElevation;\n  uniform float time;\n\n  void main() {\n    vUv = uv;\n    \n    // Create flowing movement\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    float elevation = sin(modelPosition.x * 2.0 + time * 0.5) *\n                     sin(modelPosition.y * 2.0 + time * 0.3) * 0.1;\n    \n    modelPosition.z += elevation - time * 2.0;\n    vElevation = elevation;\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n  }\n`;\n\nconst auroraFragmentShader = `\n  uniform float time;\n  uniform vec3 colorA;\n  uniform vec3 colorB;\n  uniform vec3 colorC;\n  varying vec2 vUv;\n  varying float vElevation;\n\n  void main() {\n    float mixStrength = (vElevation + 0.2) * 0.5;\n    \n    // Create tunnel effect\n    vec2 centeredUv = vUv - 0.5;\n    float distanceFromCenter = length(centeredUv);\n    float tunnelEffect = smoothstep(0.0, 0.5, distanceFromCenter);\n    \n    // Create swirling effect\n    float theta = atan(centeredUv.y, centeredUv.x);\n    float spiral = sin(distanceFromCenter * 20.0 - time * 0.5 + theta * 4.0);\n    \n    // Mix colors based on position and time\n    vec3 color1 = mix(colorA, colorB, tunnelEffect);\n    vec3 color2 = mix(colorB, colorC, mixStrength);\n    vec3 finalColor = mix(color1, color2, spiral * 0.5 + 0.5);\n    \n    // Add transparency for ethereal effect\n    float alpha = (1.0 - tunnelEffect) * 0.6;\n    \n    gl_FragColor = vec4(finalColor, alpha);\n  }\n`;\n\nexport const CosmicVortex: React.FC = () => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const particlesRef = useRef<THREE.Points | null>(null);\n  const particlePositionsRef = useRef<Float32Array | null>(null);\n  const particleSpeedsRef = useRef<Float32Array | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color('#000000');\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.z = 5;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({ \n      antialias: true, \n      alpha: false,\n      powerPreference: 'default',\n      preserveDrawingBuffer: true,\n    });\n    renderer.setClearColor('#000000', 1);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Aurora planes\n    const createAuroraPlane = (position: THREE.Vector3, rotation: THREE.Euler, colors: [string, string, string]) => {\n      const geometry = new THREE.PlaneGeometry(30, 30, 32, 32);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: auroraVertexShader,\n        fragmentShader: auroraFragmentShader,\n        uniforms: {\n          time: { value: 0 },\n          colorA: { value: new THREE.Color(colors[0]) },\n          colorB: { value: new THREE.Color(colors[1]) },\n          colorC: { value: new THREE.Color(colors[2]) }\n        },\n        transparent: true,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n        blending: THREE.AdditiveBlending\n      });\n\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.rotation.copy(rotation);\n      return mesh;\n    };\n\n    // Create tunnel of aurora planes\n    const numPlanes = 8;\n    const radius = 15;\n    const auroras: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>[] = [];\n\n    for (let i = 0; i < numPlanes; i++) {\n      const angle = (i / numPlanes) * Math.PI * 2;\n      const x = Math.cos(angle) * radius;\n      const y = Math.sin(angle) * radius;\n      \n      // Create a plane facing the center\n      const position = new THREE.Vector3(x, y, -30);\n      const rotation = new THREE.Euler(0, -angle, 0);\n      \n      const colors: [string, string, string] = [\n        i % 2 === 0 ? '#00ff88' : '#0088ff',\n        i % 3 === 0 ? '#8800ff' : '#00ccff',\n        i % 2 === 0 ? '#ffcc00' : '#cc00ff'\n      ];\n\n      const aurora = createAuroraPlane(position, rotation, colors);\n      auroras.push(aurora);\n      scene.add(aurora);\n    }\n\n    // Particles\n    const particlesGeometry = new THREE.BufferGeometry();\n    const particlesCount = 3000;\n    const positions = new Float32Array(particlesCount * 3);\n    const colors = new Float32Array(particlesCount * 3);\n    const speeds = new Float32Array(particlesCount);\n\n    const generateParticle = (index: number) => {\n      const i3 = index * 3;\n      const angle = Math.random() * Math.PI * 2;\n      const radius = Math.random() * 15 + 5; // Spread particles in a ring\n      const zPos = Math.random() * 100 - 50; // Spread along z-axis\n\n      positions[i3] = Math.cos(angle) * radius;\n      positions[i3 + 1] = Math.sin(angle) * radius;\n      positions[i3 + 2] = zPos;\n\n      speeds[index] = Math.random() * 0.2 + 0.1; // Random speed for each particle\n\n      // Color gradient based on distance from center\n      const distanceRatio = radius / 20;\n      if (distanceRatio < 0.33) {\n        colors[i3] = 0.0; // Blue\n        colors[i3 + 1] = 0.5 + Math.random() * 0.5;\n        colors[i3 + 2] = 1.0;\n      } else if (distanceRatio < 0.66) {\n        colors[i3] = 0.0; // Green\n        colors[i3 + 1] = 1.0;\n        colors[i3 + 2] = 0.5 + Math.random() * 0.5;\n      } else {\n        colors[i3] = 1.0; // Yellow\n        colors[i3 + 1] = 1.0;\n        colors[i3 + 2] = 0.0;\n      }\n    };\n\n    for (let i = 0; i < particlesCount; i++) {\n      generateParticle(i);\n    }\n\n    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n    const particlesMaterial = new THREE.PointsMaterial({\n      size: 0.03,\n      vertexColors: true,\n      transparent: true,\n      opacity: 0.8,\n      blending: THREE.AdditiveBlending,\n      sizeAttenuation: true,\n      depthWrite: false\n    });\n\n    const particles = new THREE.Points(particlesGeometry, particlesMaterial);\n    particlesRef.current = particles;\n    particlePositionsRef.current = positions;\n    particleSpeedsRef.current = speeds;\n    scene.add(particles);\n\n    // Animation\n    let time = 0;\n    const animate = () => {\n      requestAnimationFrame(animate);\n\n      time += 0.01;\n\n      // Update aurora uniforms\n      auroras.forEach((aurora, index) => {\n        const material = aurora.material as THREE.ShaderMaterial;\n        material.uniforms.time.value = time;\n        \n        // Move forward and rotate slightly\n        aurora.position.z += 0.05;\n        if (aurora.position.z > 5) {\n          aurora.position.z = -30;\n        }\n        \n        // Add slight rotation to the tunnel\n        const angle = (index / auroras.length) * Math.PI * 2 + time * 0.05;\n        const x = Math.cos(angle) * radius;\n        const y = Math.sin(angle) * radius;\n        aurora.position.x = x;\n        aurora.position.y = y;\n        aurora.rotation.y = -angle;\n      });\n\n      // Update particles\n      if (particlePositionsRef.current && particleSpeedsRef.current) {\n        const positions = particlePositionsRef.current;\n        const speeds = particleSpeedsRef.current;\n\n        for (let i = 0; i < particlesCount; i++) {\n          const i3 = i * 3;\n          positions[i3 + 2] += speeds[i];\n\n          // Reset particle when it goes too far\n          if (positions[i3 + 2] > 5) {\n            positions[i3 + 2] = -50;\n            const angle = Math.random() * Math.PI * 2;\n            const radius = Math.random() * 15 + 5;\n            positions[i3] = Math.cos(angle) * radius;\n            positions[i3 + 1] = Math.sin(angle) * radius;\n          }\n        }\n\n        particlesGeometry.attributes.position.needsUpdate = true;\n      }\n\n      renderer.render(scene, camera);\n    };\n\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      renderer.dispose();\n      if (containerRef.current) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n\n  return <VortexContainer ref={containerRef} />;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}