{"ast":null,"code":"var _jsxFileName = \"/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/CosmicVortex.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VortexContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 0;\n  pointer-events: none;\n  background: transparent;\n`;\n\n// Aurora shader\n_c = VortexContainer;\nconst auroraVertexShader = `\n  varying vec2 vUv;\n  varying float vElevation;\n  uniform float time;\n\n  void main() {\n    vUv = uv;\n    \n    // Create flowing movement\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    float elevation = sin(modelPosition.x * 2.0 + time * 0.5) *\n                     sin(modelPosition.y * 2.0 + time * 0.3) * 0.2;\n    \n    modelPosition.z += elevation;\n    vElevation = elevation;\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n  }\n`;\nconst auroraFragmentShader = `\n  uniform float time;\n  uniform vec3 colorA;\n  uniform vec3 colorB;\n  uniform vec3 colorC;\n  varying vec2 vUv;\n  varying float vElevation;\n\n  void main() {\n    float mixStrength = (vElevation + 0.2) * 0.5;\n    \n    // Create swirling effect\n    vec2 swirl = vUv - 0.5;\n    float r = length(swirl) * 2.0;\n    float theta = atan(swirl.y, swirl.x);\n    float spiral = sin(r * 10.0 - time * 0.5 + theta * 2.0);\n    \n    // Mix colors based on position and time\n    vec3 color1 = mix(colorA, colorB, mixStrength);\n    vec3 color2 = mix(colorB, colorC, mixStrength);\n    vec3 finalColor = mix(color1, color2, spiral * 0.5 + 0.5);\n    \n    // Add transparency for ethereal effect\n    float alpha = smoothstep(0.0, 0.5, mixStrength) * 0.6;\n    \n    gl_FragColor = vec4(finalColor, alpha);\n  }\n`;\nexport const CosmicVortex = () => {\n  _s();\n  const containerRef = useRef(null);\n  const rendererRef = useRef(null);\n  const particlesRef = useRef(null);\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color('#000000');\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.z = 5;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      alpha: false,\n      powerPreference: 'default',\n      preserveDrawingBuffer: true\n    });\n    renderer.setClearColor('#000000', 1);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Aurora planes\n    const createAuroraPlane = (position, rotation, colors) => {\n      const geometry = new THREE.PlaneGeometry(15, 15, 32, 32);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: auroraVertexShader,\n        fragmentShader: auroraFragmentShader,\n        uniforms: {\n          time: {\n            value: 0\n          },\n          colorA: {\n            value: new THREE.Color(colors[0])\n          },\n          colorB: {\n            value: new THREE.Color(colors[1])\n          },\n          colorC: {\n            value: new THREE.Color(colors[2])\n          }\n        },\n        transparent: true,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n        blending: THREE.AdditiveBlending\n      });\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.rotation.copy(rotation);\n      return mesh;\n    };\n\n    // Create multiple aurora planes with different colors and positions\n    const auroras = [createAuroraPlane(new THREE.Vector3(0, 0, -2), new THREE.Euler(0, 0, 0), ['#00ff88', '#0088ff', '#8800ff']), createAuroraPlane(new THREE.Vector3(2, -1, -1), new THREE.Euler(Math.PI * 0.25, 0, Math.PI * 0.1), ['#00ccff', '#ffcc00', '#00ffcc']), createAuroraPlane(new THREE.Vector3(-2, 1, -3), new THREE.Euler(-Math.PI * 0.15, 0, -Math.PI * 0.1), ['#ffcc00', '#00ccff', '#cc00ff'])];\n    auroras.forEach(aurora => scene.add(aurora));\n\n    // Particles\n    const particlesGeometry = new THREE.BufferGeometry();\n    const particlesCount = 2000;\n    const positions = new Float32Array(particlesCount * 3);\n    const velocities = new Float32Array(particlesCount * 3);\n    const colors = new Float32Array(particlesCount * 3);\n    for (let i = 0; i < particlesCount; i++) {\n      const i3 = i * 3;\n      const radius = Math.random() * 10;\n      const theta = Math.random() * Math.PI * 2;\n      const phi = Math.random() * Math.PI;\n\n      // Position in spiral formation\n      positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n      positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n      positions[i3 + 2] = radius * Math.cos(phi);\n\n      // Velocity for swirling motion\n      velocities[i3] = (Math.random() - 0.5) * 0.01;\n      velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;\n      velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;\n\n      // Random colors between green, blue, and yellow\n      const colorChoice = Math.random();\n      if (colorChoice < 0.33) {\n        colors[i3] = 0.0; // Green\n        colors[i3 + 1] = 0.8 + Math.random() * 0.2;\n        colors[i3 + 2] = 0.0;\n      } else if (colorChoice < 0.66) {\n        colors[i3] = 0.0; // Blue\n        colors[i3 + 1] = 0.0;\n        colors[i3 + 2] = 0.8 + Math.random() * 0.2;\n      } else {\n        colors[i3] = 0.8 + Math.random() * 0.2; // Yellow\n        colors[i3 + 1] = 0.8 + Math.random() * 0.2;\n        colors[i3 + 2] = 0.0;\n      }\n    }\n    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n    const particlesMaterial = new THREE.PointsMaterial({\n      size: 0.1,\n      vertexColors: true,\n      transparent: true,\n      opacity: 0.9,\n      blending: THREE.AdditiveBlending,\n      sizeAttenuation: true\n    });\n    const particles = new THREE.Points(particlesGeometry, particlesMaterial);\n    particlesRef.current = particles;\n    scene.add(particles);\n\n    // Animation\n    let time = 0;\n    const animate = () => {\n      time += 0.001;\n\n      // Update aurora uniforms\n      auroras.forEach(aurora => {\n        const material = aurora.material;\n        material.uniforms.time.value = time;\n      });\n\n      // Update particle positions\n      const positions = particles.geometry.attributes.position.array;\n      for (let i = 0; i < particlesCount; i++) {\n        const i3 = i * 3;\n\n        // Create spiral motion\n        const x = positions[i3];\n        const y = positions[i3 + 1];\n        const z = positions[i3 + 2];\n        const radius = Math.sqrt(x * x + y * y + z * z);\n        const theta = Math.atan2(y, x) + 0.1 / radius;\n        const phi = Math.acos(z / radius);\n        positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n        positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n        positions[i3 + 2] = radius * Math.cos(phi);\n\n        // Slowly pull towards center\n        positions[i3] *= 0.9999;\n        positions[i3 + 1] *= 0.9999;\n        positions[i3 + 2] *= 0.9999;\n      }\n      particles.geometry.attributes.position.needsUpdate = true;\n\n      // Rotate camera slowly\n      camera.position.x = Math.sin(time * 0.1) * 5;\n      camera.position.z = Math.cos(time * 0.1) * 5;\n      camera.lookAt(0, 0, 0);\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    };\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n    window.addEventListener('resize', handleResize);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      renderer.dispose();\n      scene.traverse(object => {\n        if (object instanceof THREE.Mesh) {\n          object.geometry.dispose();\n          if (object.material instanceof THREE.Material) {\n            object.material.dispose();\n          }\n        }\n      });\n      if (containerRef.current && renderer.domElement) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(VortexContainer, {\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 267,\n    columnNumber: 10\n  }, this);\n};\n_s(CosmicVortex, \"3tpf8feKLzKlifjdysuB/LzJhkQ=\");\n_c2 = CosmicVortex;\nvar _c, _c2;\n$RefreshReg$(_c, \"VortexContainer\");\n$RefreshReg$(_c2, \"CosmicVortex\");","map":{"version":3,"names":["React","useEffect","useRef","styled","THREE","jsxDEV","_jsxDEV","VortexContainer","div","_c","auroraVertexShader","auroraFragmentShader","CosmicVortex","_s","containerRef","rendererRef","particlesRef","current","scene","Scene","background","Color","camera","PerspectiveCamera","window","innerWidth","innerHeight","position","z","renderer","WebGLRenderer","antialias","alpha","powerPreference","preserveDrawingBuffer","setClearColor","setSize","setPixelRatio","Math","min","devicePixelRatio","appendChild","domElement","createAuroraPlane","rotation","colors","geometry","PlaneGeometry","material","ShaderMaterial","vertexShader","fragmentShader","uniforms","time","value","colorA","colorB","colorC","transparent","depthWrite","side","DoubleSide","blending","AdditiveBlending","mesh","Mesh","copy","auroras","Vector3","Euler","PI","forEach","aurora","add","particlesGeometry","BufferGeometry","particlesCount","positions","Float32Array","velocities","i","i3","radius","random","theta","phi","sin","cos","colorChoice","setAttribute","BufferAttribute","particlesMaterial","PointsMaterial","size","vertexColors","opacity","sizeAttenuation","particles","Points","animate","attributes","array","x","y","sqrt","atan2","acos","needsUpdate","lookAt","render","requestAnimationFrame","handleResize","aspect","updateProjectionMatrix","addEventListener","removeEventListener","dispose","traverse","object","Material","removeChild","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/CosmicVortex.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\n\nconst VortexContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 0;\n  pointer-events: none;\n  background: transparent;\n`;\n\n// Aurora shader\nconst auroraVertexShader = `\n  varying vec2 vUv;\n  varying float vElevation;\n  uniform float time;\n\n  void main() {\n    vUv = uv;\n    \n    // Create flowing movement\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    float elevation = sin(modelPosition.x * 2.0 + time * 0.5) *\n                     sin(modelPosition.y * 2.0 + time * 0.3) * 0.2;\n    \n    modelPosition.z += elevation;\n    vElevation = elevation;\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n  }\n`;\n\nconst auroraFragmentShader = `\n  uniform float time;\n  uniform vec3 colorA;\n  uniform vec3 colorB;\n  uniform vec3 colorC;\n  varying vec2 vUv;\n  varying float vElevation;\n\n  void main() {\n    float mixStrength = (vElevation + 0.2) * 0.5;\n    \n    // Create swirling effect\n    vec2 swirl = vUv - 0.5;\n    float r = length(swirl) * 2.0;\n    float theta = atan(swirl.y, swirl.x);\n    float spiral = sin(r * 10.0 - time * 0.5 + theta * 2.0);\n    \n    // Mix colors based on position and time\n    vec3 color1 = mix(colorA, colorB, mixStrength);\n    vec3 color2 = mix(colorB, colorC, mixStrength);\n    vec3 finalColor = mix(color1, color2, spiral * 0.5 + 0.5);\n    \n    // Add transparency for ethereal effect\n    float alpha = smoothstep(0.0, 0.5, mixStrength) * 0.6;\n    \n    gl_FragColor = vec4(finalColor, alpha);\n  }\n`;\n\nexport const CosmicVortex: React.FC = () => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const particlesRef = useRef<THREE.Points | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color('#000000');\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.z = 5;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({ \n      antialias: true, \n      alpha: false,\n      powerPreference: 'default',\n      preserveDrawingBuffer: true,\n    });\n    renderer.setClearColor('#000000', 1);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Aurora planes\n    const createAuroraPlane = (position: THREE.Vector3, rotation: THREE.Euler, colors: [string, string, string]) => {\n      const geometry = new THREE.PlaneGeometry(15, 15, 32, 32);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: auroraVertexShader,\n        fragmentShader: auroraFragmentShader,\n        uniforms: {\n          time: { value: 0 },\n          colorA: { value: new THREE.Color(colors[0]) },\n          colorB: { value: new THREE.Color(colors[1]) },\n          colorC: { value: new THREE.Color(colors[2]) }\n        },\n        transparent: true,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n        blending: THREE.AdditiveBlending\n      });\n\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.rotation.copy(rotation);\n      return mesh;\n    };\n\n    // Create multiple aurora planes with different colors and positions\n    const auroras = [\n      createAuroraPlane(\n        new THREE.Vector3(0, 0, -2),\n        new THREE.Euler(0, 0, 0),\n        ['#00ff88', '#0088ff', '#8800ff']\n      ),\n      createAuroraPlane(\n        new THREE.Vector3(2, -1, -1),\n        new THREE.Euler(Math.PI * 0.25, 0, Math.PI * 0.1),\n        ['#00ccff', '#ffcc00', '#00ffcc']\n      ),\n      createAuroraPlane(\n        new THREE.Vector3(-2, 1, -3),\n        new THREE.Euler(-Math.PI * 0.15, 0, -Math.PI * 0.1),\n        ['#ffcc00', '#00ccff', '#cc00ff']\n      )\n    ];\n\n    auroras.forEach(aurora => scene.add(aurora));\n\n    // Particles\n    const particlesGeometry = new THREE.BufferGeometry();\n    const particlesCount = 2000;\n    const positions = new Float32Array(particlesCount * 3);\n    const velocities = new Float32Array(particlesCount * 3);\n    const colors = new Float32Array(particlesCount * 3);\n\n    for (let i = 0; i < particlesCount; i++) {\n      const i3 = i * 3;\n      const radius = Math.random() * 10;\n      const theta = Math.random() * Math.PI * 2;\n      const phi = Math.random() * Math.PI;\n\n      // Position in spiral formation\n      positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n      positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n      positions[i3 + 2] = radius * Math.cos(phi);\n\n      // Velocity for swirling motion\n      velocities[i3] = (Math.random() - 0.5) * 0.01;\n      velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;\n      velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;\n\n      // Random colors between green, blue, and yellow\n      const colorChoice = Math.random();\n      if (colorChoice < 0.33) {\n        colors[i3] = 0.0; // Green\n        colors[i3 + 1] = 0.8 + Math.random() * 0.2;\n        colors[i3 + 2] = 0.0;\n      } else if (colorChoice < 0.66) {\n        colors[i3] = 0.0; // Blue\n        colors[i3 + 1] = 0.0;\n        colors[i3 + 2] = 0.8 + Math.random() * 0.2;\n      } else {\n        colors[i3] = 0.8 + Math.random() * 0.2; // Yellow\n        colors[i3 + 1] = 0.8 + Math.random() * 0.2;\n        colors[i3 + 2] = 0.0;\n      }\n    }\n\n    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n    const particlesMaterial = new THREE.PointsMaterial({\n      size: 0.1,\n      vertexColors: true,\n      transparent: true,\n      opacity: 0.9,\n      blending: THREE.AdditiveBlending,\n      sizeAttenuation: true\n    });\n\n    const particles = new THREE.Points(particlesGeometry, particlesMaterial);\n    particlesRef.current = particles;\n    scene.add(particles);\n\n    // Animation\n    let time = 0;\n    const animate = () => {\n      time += 0.001;\n\n      // Update aurora uniforms\n      auroras.forEach(aurora => {\n        const material = aurora.material as THREE.ShaderMaterial;\n        material.uniforms.time.value = time;\n      });\n\n      // Update particle positions\n      const positions = particles.geometry.attributes.position.array as Float32Array;\n      for (let i = 0; i < particlesCount; i++) {\n        const i3 = i * 3;\n        \n        // Create spiral motion\n        const x = positions[i3];\n        const y = positions[i3 + 1];\n        const z = positions[i3 + 2];\n        \n        const radius = Math.sqrt(x * x + y * y + z * z);\n        const theta = Math.atan2(y, x) + (0.1 / radius);\n        const phi = Math.acos(z / radius);\n        \n        positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n        positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n        positions[i3 + 2] = radius * Math.cos(phi);\n        \n        // Slowly pull towards center\n        positions[i3] *= 0.9999;\n        positions[i3 + 1] *= 0.9999;\n        positions[i3 + 2] *= 0.9999;\n      }\n      particles.geometry.attributes.position.needsUpdate = true;\n\n      // Rotate camera slowly\n      camera.position.x = Math.sin(time * 0.1) * 5;\n      camera.position.z = Math.cos(time * 0.1) * 5;\n      camera.lookAt(0, 0, 0);\n\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    };\n\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      renderer.dispose();\n      scene.traverse((object) => {\n        if (object instanceof THREE.Mesh) {\n          object.geometry.dispose();\n          if (object.material instanceof THREE.Material) {\n            object.material.dispose();\n          }\n        }\n      });\n      if (containerRef.current && renderer.domElement) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n\n  return <VortexContainer ref={containerRef} />;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}