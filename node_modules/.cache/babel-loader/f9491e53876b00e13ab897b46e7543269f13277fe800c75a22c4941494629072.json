{"ast":null,"code":"var _jsxFileName = \"/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/PortalBackground.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BackgroundContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: -1;\n  canvas {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n  }\n`;\n_c = BackgroundContainer;\nconst portalVertexShader = `\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  \n  void main() {\n    vUv = uv;\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\nconst portalFragmentShader = `\n  uniform float time;\n  uniform vec2 mousePos;\n  uniform vec2 mouseVelocity;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n\n  #define PI 3.14159265359\n\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n  float snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n  }\n\n  float fbm(vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 4; i++) {\n      sum += amp * snoise(p * freq);\n      freq *= 2.0;\n      amp *= 0.75;\n      p = p * 1.2 + vec2(3.2);\n    }\n    return sum;\n  }\n\n  float star(vec2 uv, float flare) {\n    float d = length(uv);\n    float m = 0.001/d;\n    return smoothstep(0.9, 1.0, m);\n  }\n\n  vec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n  }\n\n  // Wake effect function\n  float wake(vec2 uv, vec2 mousePos, float time) {\n    vec2 toCenter = vec2(0.5) - uv;\n    float centerDist = length(toCenter);\n    vec2 normalizedToCenter = normalize(toCenter);\n    \n    vec2 toMouse = mousePos - uv;\n    float mouseDist = length(toMouse);\n    vec2 normalizedToMouse = normalize(toMouse);\n    \n    // Calculate wake angle relative to flow direction\n    float wakeAngle = acos(dot(normalizedToCenter, normalizedToMouse));\n    \n    // Create wake pattern\n    float wake = exp(-mouseDist * 8.0) * exp(-abs(wakeAngle) * 2.0);\n    wake *= smoothstep(0.5, 0.0, mouseDist); // Fade with distance\n    \n    // Add flow towards center\n    wake *= smoothstep(0.0, 0.8, centerDist); // Stronger near center\n    \n    return wake;\n  }\n\n  void main() {\n    vec2 center = vec2(0.5);\n    vec2 p = vUv - center;\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n\n    // Calculate base spiral flow\n    float t = time * 0.1;\n    float spiral = angle / (2.0 * PI) + log(r) * 0.5;\n    spiral = fract(spiral * 1.0 - t);\n\n    // Create wake effect\n    float wakeEffect = wake(vUv, mousePos, time);\n    \n    // Calculate flow direction\n    vec2 flowDir = normalize(center - vUv);\n    float flowStrength = smoothstep(1.0, 0.0, r);\n\n    // Create noise with flow\n    vec2 noiseUv = vUv + flowDir * time * 0.1;\n    float noise = fbm(noiseUv * 4.0 + time * 0.1);\n    \n    // Create base colors\n    vec3 darkVoid = vec3(0.0);\n    vec3 purple = vec3(0.6, 0.0, 0.9);\n    vec3 red = vec3(0.9, 0.1, 0.1);\n\n    // Calculate red trail that flows to center\n    float redTrail = wakeEffect;\n    redTrail *= smoothstep(1.0, 0.0, r); // Fade to center\n    \n    // Mix colors based on wake and flow\n    vec3 baseColor = mix(purple, darkVoid, smoothstep(0.0, 0.8, r));\n    baseColor = mix(baseColor, red, redTrail);\n    \n    // Add energy swirl\n    float energy = spiral + noise * 0.3;\n    energy *= smoothstep(0.0, 0.2, r) * smoothstep(1.0, 0.3, r);\n    baseColor += purple * energy * 0.3;\n\n    // Add stars\n    float starTime = -time * 0.5;\n    float starLayer = 0.0;\n    \n    for(int i = 0; i < 30; i++) {\n      float fi = float(i);\n      float t = starTime * (1.0 + fi * 0.1) + fi * 1.23;\n      float scale = 0.15 + fi * 0.03;\n      \n      float radius = fract(t * 0.1 + fi * 0.123);\n      float angle = t * 0.5 + fi * 1.57;\n      vec2 starPos = vec2(cos(angle), sin(angle)) * radius;\n      \n      starPos = rotate(starPos, t * 0.1) * scale;\n      float starIntensity = star(p - starPos, 0.0) * 0.3;\n      starLayer += starIntensity * smoothstep(1.0, 0.3, length(starPos));\n    }\n\n    baseColor += vec3(1.0) * starLayer;\n\n    // Final color with void effect\n    float voidStrength = smoothstep(0.15, 0.0, r);\n    vec3 finalColor = mix(baseColor, darkVoid, voidStrength);\n\n    gl_FragColor = vec4(finalColor, 1.0);\n  }\n`;\nexport const PortalBackground = () => {\n  _s();\n  const containerRef = useRef(null);\n  const frameRef = useRef();\n  const timeRef = useRef(0);\n  const lastTimeRef = useRef(0);\n  const rendererRef = useRef(null);\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Setup\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    camera.position.z = 1;\n\n    // Add mouse tracking\n    const lastMousePos = {\n      x: 0,\n      y: 0\n    };\n    const mouseVelocity = {\n      x: 0,\n      y: 0\n    };\n    const handleMouseMove = e => {\n      var _containerRef$current;\n      const rect = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect();\n      if (!rect) return;\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n      mouseVelocity.x = x - lastMousePos.x;\n      mouseVelocity.y = y - lastMousePos.y;\n      lastMousePos.x = x;\n      lastMousePos.y = y;\n      if (material) {\n        material.uniforms.mousePos.value.set(x, y);\n        material.uniforms.mouseVelocity.value.set(mouseVelocity.x, mouseVelocity.y);\n      }\n    };\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      powerPreference: 'high-performance',\n      stencil: false,\n      depth: false,\n      alpha: true,\n      precision: 'mediump'\n    });\n    rendererRef.current = renderer;\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    const gl = renderer.getContext();\n    gl.getExtension('OES_standard_derivatives');\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.BLEND);\n    containerRef.current.appendChild(renderer.domElement);\n    const material = new THREE.ShaderMaterial({\n      uniforms: {\n        time: {\n          value: 0\n        },\n        mousePos: {\n          value: new THREE.Vector2(0.5, 0.5)\n        },\n        mouseVelocity: {\n          value: new THREE.Vector2(0.0, 0.0)\n        }\n      },\n      vertexShader: portalVertexShader,\n      fragmentShader: portalFragmentShader,\n      transparent: false,\n      depthWrite: false,\n      depthTest: false\n    });\n    const geometry = new THREE.PlaneGeometry(2, 2, 1, 1);\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n    const animate = timestamp => {\n      if (!material || !renderer) return;\n      const deltaTime = timestamp - lastTimeRef.current;\n      lastTimeRef.current = timestamp;\n      const targetFrameTime = 1000 / 60;\n      const frameProgress = Math.min(deltaTime / targetFrameTime, 1);\n      timeRef.current += 0.01 * frameProgress;\n      material.uniforms.time.value = timeRef.current;\n      renderer.render(scene, camera);\n      frameRef.current = requestAnimationFrame(animate);\n    };\n    lastTimeRef.current = performance.now();\n    frameRef.current = requestAnimationFrame(animate);\n    let resizeTimeout;\n    let lastWidth = window.innerWidth;\n    let lastHeight = window.innerHeight;\n    const handleResize = () => {\n      if (resizeTimeout) {\n        cancelAnimationFrame(resizeTimeout);\n      }\n      resizeTimeout = requestAnimationFrame(() => {\n        if (!renderer) return;\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        if (width !== lastWidth || height !== lastHeight) {\n          renderer.setSize(width, height);\n          lastWidth = width;\n          lastHeight = height;\n        }\n      });\n    };\n    window.addEventListener('resize', handleResize, {\n      passive: true\n    });\n    window.addEventListener('mousemove', handleMouseMove, {\n      passive: true\n    });\n    return () => {\n      var _containerRef$current2;\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n      if (resizeTimeout) {\n        cancelAnimationFrame(resizeTimeout);\n      }\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('mousemove', handleMouseMove);\n      renderer.dispose();\n      geometry.dispose();\n      material.dispose();\n      if ((_containerRef$current2 = containerRef.current) !== null && _containerRef$current2 !== void 0 && _containerRef$current2.contains(renderer.domElement)) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n      rendererRef.current = null;\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(BackgroundContainer, {\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 325,\n    columnNumber: 10\n  }, this);\n};\n_s(PortalBackground, \"JhcbDYm+CmBObDCmLsL11AsXCeY=\");\n_c2 = PortalBackground;\nvar _c, _c2;\n$RefreshReg$(_c, \"BackgroundContainer\");\n$RefreshReg$(_c2, \"PortalBackground\");","map":{"version":3,"names":["React","useEffect","useRef","styled","THREE","jsxDEV","_jsxDEV","BackgroundContainer","div","_c","portalVertexShader","portalFragmentShader","PortalBackground","_s","containerRef","frameRef","timeRef","lastTimeRef","rendererRef","current","scene","Scene","camera","OrthographicCamera","position","z","lastMousePos","x","y","mouseVelocity","handleMouseMove","e","_containerRef$current","rect","getBoundingClientRect","clientX","left","width","clientY","top","height","material","uniforms","mousePos","value","set","renderer","WebGLRenderer","antialias","powerPreference","stencil","depth","alpha","precision","setSize","window","innerWidth","innerHeight","setPixelRatio","Math","min","devicePixelRatio","gl","getContext","getExtension","disable","DEPTH_TEST","BLEND","appendChild","domElement","ShaderMaterial","time","Vector2","vertexShader","fragmentShader","transparent","depthWrite","depthTest","geometry","PlaneGeometry","mesh","Mesh","add","animate","timestamp","deltaTime","targetFrameTime","frameProgress","render","requestAnimationFrame","performance","now","resizeTimeout","lastWidth","lastHeight","handleResize","cancelAnimationFrame","addEventListener","passive","_containerRef$current2","removeEventListener","dispose","contains","removeChild","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/PortalBackground.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\n\nconst BackgroundContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: -1;\n  canvas {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n  }\n`;\n\nconst portalVertexShader = `\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  \n  void main() {\n    vUv = uv;\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\nconst portalFragmentShader = `\n  uniform float time;\n  uniform vec2 mousePos;\n  uniform vec2 mouseVelocity;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n\n  #define PI 3.14159265359\n\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n  float snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n  }\n\n  float fbm(vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 4; i++) {\n      sum += amp * snoise(p * freq);\n      freq *= 2.0;\n      amp *= 0.75;\n      p = p * 1.2 + vec2(3.2);\n    }\n    return sum;\n  }\n\n  float star(vec2 uv, float flare) {\n    float d = length(uv);\n    float m = 0.001/d;\n    return smoothstep(0.9, 1.0, m);\n  }\n\n  vec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n  }\n\n  // Wake effect function\n  float wake(vec2 uv, vec2 mousePos, float time) {\n    vec2 toCenter = vec2(0.5) - uv;\n    float centerDist = length(toCenter);\n    vec2 normalizedToCenter = normalize(toCenter);\n    \n    vec2 toMouse = mousePos - uv;\n    float mouseDist = length(toMouse);\n    vec2 normalizedToMouse = normalize(toMouse);\n    \n    // Calculate wake angle relative to flow direction\n    float wakeAngle = acos(dot(normalizedToCenter, normalizedToMouse));\n    \n    // Create wake pattern\n    float wake = exp(-mouseDist * 8.0) * exp(-abs(wakeAngle) * 2.0);\n    wake *= smoothstep(0.5, 0.0, mouseDist); // Fade with distance\n    \n    // Add flow towards center\n    wake *= smoothstep(0.0, 0.8, centerDist); // Stronger near center\n    \n    return wake;\n  }\n\n  void main() {\n    vec2 center = vec2(0.5);\n    vec2 p = vUv - center;\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n\n    // Calculate base spiral flow\n    float t = time * 0.1;\n    float spiral = angle / (2.0 * PI) + log(r) * 0.5;\n    spiral = fract(spiral * 1.0 - t);\n\n    // Create wake effect\n    float wakeEffect = wake(vUv, mousePos, time);\n    \n    // Calculate flow direction\n    vec2 flowDir = normalize(center - vUv);\n    float flowStrength = smoothstep(1.0, 0.0, r);\n\n    // Create noise with flow\n    vec2 noiseUv = vUv + flowDir * time * 0.1;\n    float noise = fbm(noiseUv * 4.0 + time * 0.1);\n    \n    // Create base colors\n    vec3 darkVoid = vec3(0.0);\n    vec3 purple = vec3(0.6, 0.0, 0.9);\n    vec3 red = vec3(0.9, 0.1, 0.1);\n\n    // Calculate red trail that flows to center\n    float redTrail = wakeEffect;\n    redTrail *= smoothstep(1.0, 0.0, r); // Fade to center\n    \n    // Mix colors based on wake and flow\n    vec3 baseColor = mix(purple, darkVoid, smoothstep(0.0, 0.8, r));\n    baseColor = mix(baseColor, red, redTrail);\n    \n    // Add energy swirl\n    float energy = spiral + noise * 0.3;\n    energy *= smoothstep(0.0, 0.2, r) * smoothstep(1.0, 0.3, r);\n    baseColor += purple * energy * 0.3;\n\n    // Add stars\n    float starTime = -time * 0.5;\n    float starLayer = 0.0;\n    \n    for(int i = 0; i < 30; i++) {\n      float fi = float(i);\n      float t = starTime * (1.0 + fi * 0.1) + fi * 1.23;\n      float scale = 0.15 + fi * 0.03;\n      \n      float radius = fract(t * 0.1 + fi * 0.123);\n      float angle = t * 0.5 + fi * 1.57;\n      vec2 starPos = vec2(cos(angle), sin(angle)) * radius;\n      \n      starPos = rotate(starPos, t * 0.1) * scale;\n      float starIntensity = star(p - starPos, 0.0) * 0.3;\n      starLayer += starIntensity * smoothstep(1.0, 0.3, length(starPos));\n    }\n\n    baseColor += vec3(1.0) * starLayer;\n\n    // Final color with void effect\n    float voidStrength = smoothstep(0.15, 0.0, r);\n    vec3 finalColor = mix(baseColor, darkVoid, voidStrength);\n\n    gl_FragColor = vec4(finalColor, 1.0);\n  }\n`;\n\nexport const PortalBackground: React.FC = () => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const frameRef = useRef<number>();\n  const timeRef = useRef<number>(0);\n  const lastTimeRef = useRef<number>(0);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Setup\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    camera.position.z = 1;\n\n    // Add mouse tracking\n    const lastMousePos = { x: 0, y: 0 };\n    const mouseVelocity = { x: 0, y: 0 };\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = containerRef.current?.getBoundingClientRect();\n      if (!rect) return;\n\n      const x = (e.clientX - rect.left) / rect.width;\n      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n\n      mouseVelocity.x = x - lastMousePos.x;\n      mouseVelocity.y = y - lastMousePos.y;\n      \n      lastMousePos.x = x;\n      lastMousePos.y = y;\n\n      if (material) {\n        material.uniforms.mousePos.value.set(x, y);\n        material.uniforms.mouseVelocity.value.set(mouseVelocity.x, mouseVelocity.y);\n      }\n    };\n\n    const renderer = new THREE.WebGLRenderer({ \n      antialias: true,\n      powerPreference: 'high-performance',\n      stencil: false,\n      depth: false,\n      alpha: true,\n      precision: 'mediump'\n    });\n    \n    rendererRef.current = renderer;\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    \n    const gl = renderer.getContext();\n    gl.getExtension('OES_standard_derivatives');\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.BLEND);\n\n    containerRef.current.appendChild(renderer.domElement);\n\n    const material = new THREE.ShaderMaterial({\n      uniforms: {\n        time: { value: 0 },\n        mousePos: { value: new THREE.Vector2(0.5, 0.5) },\n        mouseVelocity: { value: new THREE.Vector2(0.0, 0.0) }\n      },\n      vertexShader: portalVertexShader,\n      fragmentShader: portalFragmentShader,\n      transparent: false,\n      depthWrite: false,\n      depthTest: false\n    });\n\n    const geometry = new THREE.PlaneGeometry(2, 2, 1, 1);\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    const animate = (timestamp: number) => {\n      if (!material || !renderer) return;\n\n      const deltaTime = timestamp - lastTimeRef.current;\n      lastTimeRef.current = timestamp;\n      \n      const targetFrameTime = 1000 / 60;\n      const frameProgress = Math.min(deltaTime / targetFrameTime, 1);\n      timeRef.current += 0.01 * frameProgress;\n      \n      material.uniforms.time.value = timeRef.current;\n\n      renderer.render(scene, camera);\n      frameRef.current = requestAnimationFrame(animate);\n    };\n\n    lastTimeRef.current = performance.now();\n    frameRef.current = requestAnimationFrame(animate);\n\n    let resizeTimeout: number;\n    let lastWidth = window.innerWidth;\n    let lastHeight = window.innerHeight;\n    \n    const handleResize = () => {\n      if (resizeTimeout) {\n        cancelAnimationFrame(resizeTimeout);\n      }\n      \n      resizeTimeout = requestAnimationFrame(() => {\n        if (!renderer) return;\n        \n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        \n        if (width !== lastWidth || height !== lastHeight) {\n          renderer.setSize(width, height);\n          lastWidth = width;\n          lastHeight = height;\n        }\n      });\n    };\n\n    window.addEventListener('resize', handleResize, { passive: true });\n    window.addEventListener('mousemove', handleMouseMove, { passive: true });\n\n    return () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n      if (resizeTimeout) {\n        cancelAnimationFrame(resizeTimeout);\n      }\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('mousemove', handleMouseMove);\n      \n      renderer.dispose();\n      geometry.dispose();\n      material.dispose();\n      \n      if (containerRef.current?.contains(renderer.domElement)) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n      \n      rendererRef.current = null;\n    };\n  }, []);\n\n  return <BackgroundContainer ref={containerRef} />;\n};"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAO,KAAKC,KAAK,MAAM,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE/B,MAAMC,mBAAmB,GAAGJ,MAAM,CAACK,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,EAAA,GAdIF,mBAAmB;AAgBzB,MAAMG,kBAAkB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,oBAAoB,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,OAAO,MAAMC,gBAA0B,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC9C,MAAMC,YAAY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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}