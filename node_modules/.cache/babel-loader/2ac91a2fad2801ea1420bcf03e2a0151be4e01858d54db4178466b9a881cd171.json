{"ast":null,"code":"var _jsxFileName = \"/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/PortalBackground.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BackgroundContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: -1;\n  canvas {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n  }\n`;\n_c = BackgroundContainer;\nconst portalVertexShader = `\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  \n  void main() {\n    vUv = uv;\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\nconst portalFragmentShader = `\n  uniform float time;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n\n  #define PI 3.14159265359\n\n  // Noise functions\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n  float snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n      + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n  }\n\n  float fbm(vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    // More octaves for smoother detail\n    for(int i = 0; i < 8; i++) {\n      sum += amp * snoise(p * freq);\n      freq *= 2.0;\n      amp *= 0.5;\n      p = p * 1.2 + vec2(3.2);\n    }\n    return sum;\n  }\n\n  vec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n  }\n\n  // Star field function\n  float star(vec2 uv, float flare) {\n    float d = length(uv);\n    float m = 0.002/d;  // Reduced from 0.02 to make stars tiny\n    \n    // Core star\n    float core = smoothstep(0.9, 1.0, m);\n    \n    // Bright center\n    float brightCore = smoothstep(0.95, 1.0, m) * 2.0;\n    \n    // Outer glow\n    float glow = 0.004/d;\n    glow = smoothstep(0.8, 1.0, glow) * 0.4;\n    \n    // Tiny rays for sparkle\n    float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 4000.0));\n    rays *= 0.2 * flare;\n    \n    return core + brightCore + glow + rays;\n  }\n\n  void main() {\n    vec2 center = vec2(0.5, 0.5);\n    vec2 p = vUv - center;\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n\n    // Create seamless spiral effect\n    float t = time * 0.2;\n    float spiral = angle / (2.0 * PI) + log(r) * 0.5;\n    spiral = fract(spiral * 4.0 - t); // Adjust multiplier for number of arms\n\n    // Create seamless noise\n    vec2 rotatedUv = rotate(p, t);\n    float noise1 = fbm(vec2(r * 4.0 + t, spiral * 6.0));\n    float noise2 = fbm(vec2(r * 3.0 - t * 0.5, spiral * 4.0));\n    float noise3 = fbm(rotatedUv * 3.0 + t * 0.2);\n\n    // Enhanced spiral flow\n    float flow = smoothstep(0.0, 1.0, spiral);\n    flow *= smoothstep(1.0, 0.0, spiral);\n    \n    // Improved energy effect\n    float energy = flow + noise1 * 0.5;\n    energy *= smoothstep(0.0, 0.2, r); // Fade in from center\n    energy *= smoothstep(1.0, 0.3, r); // Fade out at edges\n\n    // Color palette\n    vec3 darkVoid = vec3(0.0, 0.0, 0.0);\n    vec3 energyColor1 = vec3(0.7, 0.0, 1.0); // Bright purple\n    vec3 energyColor2 = vec3(0.4, 0.0, 0.8); // Deep purple\n    vec3 energyColor3 = vec3(0.2, 0.0, 0.6); // Dark purple\n\n    // Create base spiral structure\n    float spiralIntensity = smoothstep(0.0, 1.0, energy);\n    vec3 finalColor = mix(darkVoid, energyColor1, spiralIntensity * (1.0 - r));\n\n    // Add layered energy effects\n    float energyMix1 = noise1 * 0.7 * (1.0 - r);\n    float energyMix2 = noise2 * 0.5 * (1.0 - r);\n    float energyMix3 = noise3 * 0.3 * (1.0 - r);\n\n    finalColor = mix(finalColor, energyColor1, energyMix1);\n    finalColor = mix(finalColor, energyColor2, energyMix2);\n    finalColor = mix(finalColor, energyColor3, energyMix3);\n\n    // Add depth and glow\n    float innerGlow = smoothstep(0.4, 0.0, r);\n    finalColor += energyColor1 * innerGlow * 0.3;\n\n    // Enhance the void effect\n    float voidStrength = smoothstep(0.15, 0.0, r);\n    finalColor = mix(finalColor, darkVoid, voidStrength);\n\n    // Add subtle pulsing\n    float pulse = sin(time * 0.5) * 0.5 + 0.5;\n    finalColor += energyColor1 * pulse * 0.1 * (1.0 - r);\n\n    // Add star field\n    float starTime = -time * 0.5;\n    float starLayer1 = 0.0;\n    float starLayer2 = 0.0;\n    \n    // Create multiple star layers\n    for(int i = 0; i < 35; i++) {  // More stars\n      float fi = float(i);\n      float t = starTime * (1.0 + fi * 0.1) + fi * 1.23;\n      float scale = 0.2 + fi * 0.05;  // Smaller scale\n      \n      // Star position with spiral motion\n      float radius = fract(t * 0.1 + fi * 0.123) * 1.2;\n      float angle = -t * 0.5 + fi * 1.57;\n      vec2 xy = vec2(cos(angle), sin(angle)) * radius;\n      \n      vec2 starPos = rotate(xy, -t * 0.2);\n      starPos = starPos * scale;\n      \n      float starIntensity = star(p - starPos, 0.15) * 2.0;  // Increased brightness\n      \n      float fadeOut = smoothstep(0.0, 0.1, length(starPos));\n      float fadeIn = smoothstep(1.0, 0.3, length(starPos));\n      \n      starLayer1 += starIntensity * fadeOut * fadeIn * 0.3;\n    }\n    \n    // Second star layer with different timing\n    for(int i = 0; i < 25; i++) {\n      float fi = float(i);\n      float t = starTime * (0.8 + fi * 0.1) + fi * 2.34;\n      float scale = 0.15 + fi * 0.03;  // Even smaller scale\n      \n      float radius = fract(t * 0.15 + fi * 0.234) * 1.0;\n      float angle = -t * 0.7 + fi * 2.12;\n      vec2 xy = vec2(cos(angle), sin(angle)) * radius;\n      \n      vec2 starPos = rotate(xy, -t * 0.25);\n      starPos = starPos * scale;\n      \n      float starIntensity = star(p - starPos, 0.1) * 1.5;  // Increased brightness\n      float fadeOut = smoothstep(0.0, 0.15, length(starPos));\n      float fadeIn = smoothstep(1.0, 0.4, length(starPos));\n      \n      starLayer2 += starIntensity * fadeOut * fadeIn * 0.25;\n    }\n\n    // Add stars to final color with increased brightness\n    vec3 starColor1 = vec3(1.0, 0.95, 1.0);  // Almost white\n    vec3 starColor2 = vec3(0.9, 0.85, 1.0);  // Slightly purple white\n    \n    finalColor += starColor1 * starLayer1 * 1.5;  // Increased brightness\n    finalColor += starColor2 * starLayer2 * 1.2;\n\n    // Ensure stars fade into the void\n    float voidFade = smoothstep(0.1, 0.25, r);\n    finalColor = mix(darkVoid, finalColor, voidFade);\n\n    // Add bloom effect to bright areas\n    float brightness = max(finalColor.r, max(finalColor.g, finalColor.b));\n    float bloom = smoothstep(0.7, 1.0, brightness) * 0.5;\n    finalColor += finalColor * bloom;\n\n    gl_FragColor = vec4(finalColor, 1.0);\n  }\n`;\nexport const PortalBackground = () => {\n  _s();\n  const containerRef = useRef(null);\n  const frameRef = useRef();\n  const timeRef = useRef(0);\n  const lastTimeRef = useRef(0);\n  const rendererRef = useRef(null);\n  const isVisibleRef = useRef(true);\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Setup with lower quality for better performance\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    camera.position.z = 1;\n\n    // Optimize renderer settings\n    const renderer = new THREE.WebGLRenderer({\n      antialias: false,\n      // Disable antialiasing for performance\n      powerPreference: 'high-performance',\n      stencil: false,\n      depth: false,\n      alpha: true,\n      precision: 'lowp' // Use low precision for better performance\n    });\n    rendererRef.current = renderer;\n    renderer.setSize(window.innerWidth, window.innerHeight);\n\n    // Use lower pixel ratio for better performance\n    const pixelRatio = Math.min(window.devicePixelRatio, 1.5);\n    renderer.setPixelRatio(pixelRatio);\n\n    // Enable WebGL optimizations\n    const gl = renderer.getContext();\n    gl.getExtension('OES_standard_derivatives');\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.BLEND);\n    containerRef.current.appendChild(renderer.domElement);\n\n    // Create portal material with optimized settings\n    const material = new THREE.ShaderMaterial({\n      uniforms: {\n        time: {\n          value: 0\n        }\n      },\n      vertexShader: portalVertexShader,\n      fragmentShader: portalFragmentShader,\n      transparent: false,\n      depthWrite: false,\n      depthTest: false\n    });\n    const geometry = new THREE.PlaneGeometry(2, 2, 1, 1);\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    // Visibility observer for performance\n    const observer = new IntersectionObserver(entries => {\n      isVisibleRef.current = entries[0].isIntersecting;\n    }, {\n      threshold: 0\n    });\n    observer.observe(containerRef.current);\n\n    // Optimized animation loop\n    let lastFrame = performance.now();\n    const targetFPS = 60;\n    const frameInterval = 1000 / targetFPS;\n    const animate = timestamp => {\n      if (!material || !renderer || !isVisibleRef.current) {\n        frameRef.current = requestAnimationFrame(animate);\n        return;\n      }\n      const delta = timestamp - lastFrame;\n\n      // Only render if enough time has passed\n      if (delta > frameInterval) {\n        // Smooth time update\n        const frameProgress = Math.min(delta / frameInterval, 2);\n        timeRef.current += 0.008 * frameProgress; // Reduced time step for smoother animation\n        material.uniforms.time.value = timeRef.current;\n        renderer.render(scene, camera);\n        lastFrame = timestamp - delta % frameInterval;\n      }\n      frameRef.current = requestAnimationFrame(animate);\n    };\n    lastTimeRef.current = performance.now();\n    frameRef.current = requestAnimationFrame(animate);\n\n    // Optimized resize with throttle\n    let resizeTimeout;\n    let lastWidth = window.innerWidth;\n    let lastHeight = window.innerHeight;\n    const handleResize = () => {\n      if (resizeTimeout) {\n        cancelAnimationFrame(resizeTimeout);\n      }\n      resizeTimeout = requestAnimationFrame(() => {\n        if (!renderer) return;\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        if (width !== lastWidth || height !== lastHeight) {\n          renderer.setSize(width, height);\n          lastWidth = width;\n          lastHeight = height;\n        }\n      });\n    };\n    window.addEventListener('resize', handleResize, {\n      passive: true\n    });\n    return () => {\n      var _containerRef$current;\n      observer.disconnect();\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n      if (resizeTimeout) {\n        cancelAnimationFrame(resizeTimeout);\n      }\n      window.removeEventListener('resize', handleResize);\n      renderer.dispose();\n      geometry.dispose();\n      material.dispose();\n      if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(renderer.domElement)) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n      rendererRef.current = null;\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(BackgroundContainer, {\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 382,\n    columnNumber: 10\n  }, this);\n};\n_s(PortalBackground, \"4hniZAIwe8eTWgw2gSp5tcyz1YE=\");\n_c2 = PortalBackground;\nvar _c, _c2;\n$RefreshReg$(_c, \"BackgroundContainer\");\n$RefreshReg$(_c2, \"PortalBackground\");","map":{"version":3,"names":["React","useEffect","useRef","styled","THREE","jsxDEV","_jsxDEV","BackgroundContainer","div","_c","portalVertexShader","portalFragmentShader","PortalBackground","_s","containerRef","frameRef","timeRef","lastTimeRef","rendererRef","isVisibleRef","current","scene","Scene","camera","OrthographicCamera","position","z","renderer","WebGLRenderer","antialias","powerPreference","stencil","depth","alpha","precision","setSize","window","innerWidth","innerHeight","pixelRatio","Math","min","devicePixelRatio","setPixelRatio","gl","getContext","getExtension","disable","DEPTH_TEST","BLEND","appendChild","domElement","material","ShaderMaterial","uniforms","time","value","vertexShader","fragmentShader","transparent","depthWrite","depthTest","geometry","PlaneGeometry","mesh","Mesh","add","observer","IntersectionObserver","entries","isIntersecting","threshold","observe","lastFrame","performance","now","targetFPS","frameInterval","animate","timestamp","requestAnimationFrame","delta","frameProgress","render","resizeTimeout","lastWidth","lastHeight","handleResize","cancelAnimationFrame","width","height","addEventListener","passive","_containerRef$current","disconnect","removeEventListener","dispose","contains","removeChild","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/PortalBackground.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\n\nconst BackgroundContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: -1;\n  canvas {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n  }\n`;\n\nconst portalVertexShader = `\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  \n  void main() {\n    vUv = uv;\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\nconst portalFragmentShader = `\n  uniform float time;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n\n  #define PI 3.14159265359\n\n  // Noise functions\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n  float snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n      + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n  }\n\n  float fbm(vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    // More octaves for smoother detail\n    for(int i = 0; i < 8; i++) {\n      sum += amp * snoise(p * freq);\n      freq *= 2.0;\n      amp *= 0.5;\n      p = p * 1.2 + vec2(3.2);\n    }\n    return sum;\n  }\n\n  vec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n  }\n\n  // Star field function\n  float star(vec2 uv, float flare) {\n    float d = length(uv);\n    float m = 0.002/d;  // Reduced from 0.02 to make stars tiny\n    \n    // Core star\n    float core = smoothstep(0.9, 1.0, m);\n    \n    // Bright center\n    float brightCore = smoothstep(0.95, 1.0, m) * 2.0;\n    \n    // Outer glow\n    float glow = 0.004/d;\n    glow = smoothstep(0.8, 1.0, glow) * 0.4;\n    \n    // Tiny rays for sparkle\n    float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 4000.0));\n    rays *= 0.2 * flare;\n    \n    return core + brightCore + glow + rays;\n  }\n\n  void main() {\n    vec2 center = vec2(0.5, 0.5);\n    vec2 p = vUv - center;\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n\n    // Create seamless spiral effect\n    float t = time * 0.2;\n    float spiral = angle / (2.0 * PI) + log(r) * 0.5;\n    spiral = fract(spiral * 4.0 - t); // Adjust multiplier for number of arms\n\n    // Create seamless noise\n    vec2 rotatedUv = rotate(p, t);\n    float noise1 = fbm(vec2(r * 4.0 + t, spiral * 6.0));\n    float noise2 = fbm(vec2(r * 3.0 - t * 0.5, spiral * 4.0));\n    float noise3 = fbm(rotatedUv * 3.0 + t * 0.2);\n\n    // Enhanced spiral flow\n    float flow = smoothstep(0.0, 1.0, spiral);\n    flow *= smoothstep(1.0, 0.0, spiral);\n    \n    // Improved energy effect\n    float energy = flow + noise1 * 0.5;\n    energy *= smoothstep(0.0, 0.2, r); // Fade in from center\n    energy *= smoothstep(1.0, 0.3, r); // Fade out at edges\n\n    // Color palette\n    vec3 darkVoid = vec3(0.0, 0.0, 0.0);\n    vec3 energyColor1 = vec3(0.7, 0.0, 1.0); // Bright purple\n    vec3 energyColor2 = vec3(0.4, 0.0, 0.8); // Deep purple\n    vec3 energyColor3 = vec3(0.2, 0.0, 0.6); // Dark purple\n\n    // Create base spiral structure\n    float spiralIntensity = smoothstep(0.0, 1.0, energy);\n    vec3 finalColor = mix(darkVoid, energyColor1, spiralIntensity * (1.0 - r));\n\n    // Add layered energy effects\n    float energyMix1 = noise1 * 0.7 * (1.0 - r);\n    float energyMix2 = noise2 * 0.5 * (1.0 - r);\n    float energyMix3 = noise3 * 0.3 * (1.0 - r);\n\n    finalColor = mix(finalColor, energyColor1, energyMix1);\n    finalColor = mix(finalColor, energyColor2, energyMix2);\n    finalColor = mix(finalColor, energyColor3, energyMix3);\n\n    // Add depth and glow\n    float innerGlow = smoothstep(0.4, 0.0, r);\n    finalColor += energyColor1 * innerGlow * 0.3;\n\n    // Enhance the void effect\n    float voidStrength = smoothstep(0.15, 0.0, r);\n    finalColor = mix(finalColor, darkVoid, voidStrength);\n\n    // Add subtle pulsing\n    float pulse = sin(time * 0.5) * 0.5 + 0.5;\n    finalColor += energyColor1 * pulse * 0.1 * (1.0 - r);\n\n    // Add star field\n    float starTime = -time * 0.5;\n    float starLayer1 = 0.0;\n    float starLayer2 = 0.0;\n    \n    // Create multiple star layers\n    for(int i = 0; i < 35; i++) {  // More stars\n      float fi = float(i);\n      float t = starTime * (1.0 + fi * 0.1) + fi * 1.23;\n      float scale = 0.2 + fi * 0.05;  // Smaller scale\n      \n      // Star position with spiral motion\n      float radius = fract(t * 0.1 + fi * 0.123) * 1.2;\n      float angle = -t * 0.5 + fi * 1.57;\n      vec2 xy = vec2(cos(angle), sin(angle)) * radius;\n      \n      vec2 starPos = rotate(xy, -t * 0.2);\n      starPos = starPos * scale;\n      \n      float starIntensity = star(p - starPos, 0.15) * 2.0;  // Increased brightness\n      \n      float fadeOut = smoothstep(0.0, 0.1, length(starPos));\n      float fadeIn = smoothstep(1.0, 0.3, length(starPos));\n      \n      starLayer1 += starIntensity * fadeOut * fadeIn * 0.3;\n    }\n    \n    // Second star layer with different timing\n    for(int i = 0; i < 25; i++) {\n      float fi = float(i);\n      float t = starTime * (0.8 + fi * 0.1) + fi * 2.34;\n      float scale = 0.15 + fi * 0.03;  // Even smaller scale\n      \n      float radius = fract(t * 0.15 + fi * 0.234) * 1.0;\n      float angle = -t * 0.7 + fi * 2.12;\n      vec2 xy = vec2(cos(angle), sin(angle)) * radius;\n      \n      vec2 starPos = rotate(xy, -t * 0.25);\n      starPos = starPos * scale;\n      \n      float starIntensity = star(p - starPos, 0.1) * 1.5;  // Increased brightness\n      float fadeOut = smoothstep(0.0, 0.15, length(starPos));\n      float fadeIn = smoothstep(1.0, 0.4, length(starPos));\n      \n      starLayer2 += starIntensity * fadeOut * fadeIn * 0.25;\n    }\n\n    // Add stars to final color with increased brightness\n    vec3 starColor1 = vec3(1.0, 0.95, 1.0);  // Almost white\n    vec3 starColor2 = vec3(0.9, 0.85, 1.0);  // Slightly purple white\n    \n    finalColor += starColor1 * starLayer1 * 1.5;  // Increased brightness\n    finalColor += starColor2 * starLayer2 * 1.2;\n\n    // Ensure stars fade into the void\n    float voidFade = smoothstep(0.1, 0.25, r);\n    finalColor = mix(darkVoid, finalColor, voidFade);\n\n    // Add bloom effect to bright areas\n    float brightness = max(finalColor.r, max(finalColor.g, finalColor.b));\n    float bloom = smoothstep(0.7, 1.0, brightness) * 0.5;\n    finalColor += finalColor * bloom;\n\n    gl_FragColor = vec4(finalColor, 1.0);\n  }\n`;\n\nexport const PortalBackground: React.FC = () => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const frameRef = useRef<number>();\n  const timeRef = useRef<number>(0);\n  const lastTimeRef = useRef<number>(0);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const isVisibleRef = useRef(true);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Setup with lower quality for better performance\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    camera.position.z = 1;\n\n    // Optimize renderer settings\n    const renderer = new THREE.WebGLRenderer({ \n      antialias: false, // Disable antialiasing for performance\n      powerPreference: 'high-performance',\n      stencil: false,\n      depth: false,\n      alpha: true,\n      precision: 'lowp' // Use low precision for better performance\n    });\n    \n    rendererRef.current = renderer;\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    \n    // Use lower pixel ratio for better performance\n    const pixelRatio = Math.min(window.devicePixelRatio, 1.5);\n    renderer.setPixelRatio(pixelRatio);\n    \n    // Enable WebGL optimizations\n    const gl = renderer.getContext();\n    gl.getExtension('OES_standard_derivatives');\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.BLEND);\n\n    containerRef.current.appendChild(renderer.domElement);\n\n    // Create portal material with optimized settings\n    const material = new THREE.ShaderMaterial({\n      uniforms: {\n        time: { value: 0 }\n      },\n      vertexShader: portalVertexShader,\n      fragmentShader: portalFragmentShader,\n      transparent: false,\n      depthWrite: false,\n      depthTest: false\n    });\n\n    const geometry = new THREE.PlaneGeometry(2, 2, 1, 1);\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    // Visibility observer for performance\n    const observer = new IntersectionObserver(\n      (entries) => {\n        isVisibleRef.current = entries[0].isIntersecting;\n      },\n      { threshold: 0 }\n    );\n    observer.observe(containerRef.current);\n\n    // Optimized animation loop\n    let lastFrame = performance.now();\n    const targetFPS = 60;\n    const frameInterval = 1000 / targetFPS;\n    \n    const animate = (timestamp: number) => {\n      if (!material || !renderer || !isVisibleRef.current) {\n        frameRef.current = requestAnimationFrame(animate);\n        return;\n      }\n\n      const delta = timestamp - lastFrame;\n      \n      // Only render if enough time has passed\n      if (delta > frameInterval) {\n        // Smooth time update\n        const frameProgress = Math.min(delta / frameInterval, 2);\n        timeRef.current += 0.008 * frameProgress; // Reduced time step for smoother animation\n        material.uniforms.time.value = timeRef.current;\n\n        renderer.render(scene, camera);\n        lastFrame = timestamp - (delta % frameInterval);\n      }\n\n      frameRef.current = requestAnimationFrame(animate);\n    };\n\n    lastTimeRef.current = performance.now();\n    frameRef.current = requestAnimationFrame(animate);\n\n    // Optimized resize with throttle\n    let resizeTimeout: number;\n    let lastWidth = window.innerWidth;\n    let lastHeight = window.innerHeight;\n    \n    const handleResize = () => {\n      if (resizeTimeout) {\n        cancelAnimationFrame(resizeTimeout);\n      }\n      \n      resizeTimeout = requestAnimationFrame(() => {\n        if (!renderer) return;\n        \n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        \n        if (width !== lastWidth || height !== lastHeight) {\n          renderer.setSize(width, height);\n          lastWidth = width;\n          lastHeight = height;\n        }\n      });\n    };\n\n    window.addEventListener('resize', handleResize, { passive: true });\n\n    return () => {\n      observer.disconnect();\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n      if (resizeTimeout) {\n        cancelAnimationFrame(resizeTimeout);\n      }\n      window.removeEventListener('resize', handleResize);\n      \n      renderer.dispose();\n      geometry.dispose();\n      material.dispose();\n      \n      if (containerRef.current?.contains(renderer.domElement)) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n      \n      rendererRef.current = null;\n    };\n  }, []);\n\n  return <BackgroundContainer ref={containerRef} />;\n}; "],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAO,KAAKC,KAAK,MAAM,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE/B,MAAMC,mBAAmB,GAAGJ,MAAM,CAACK,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,EAAA,GAdIF,mBAAmB;AAgBzB,MAAMG,kBAAkB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,oBAAoB,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,OAAO,MAAMC,gBAA0B,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC9C,MAAMC,YAAY,GAAGZ,MAAM,CAAiB,IAAI,CAAC;EACjD,MAAMa,QAAQ,GAAGb,MAAM,CAAS,CAAC;EACjC,MAAMc,OAAO,GAAGd,MAAM,CAAS,CAAC,CAAC;EACjC,MAAMe,WAAW,GAAGf,MAAM,CAAS,CAAC,CAAC;EACrC,MAAMgB,WAAW,GAAGhB,MAAM,CAA6B,IAAI,CAAC;EAC5D,MAAMiB,YAAY,GAAGjB,MAAM,CAAC,IAAI,CAAC;EAEjCD,SAAS,CAAC,MAAM;IACd,IAAI,CAACa,YAAY,CAACM,OAAO,EAAE;;IAE3B;IACA,MAAMC,KAAK,GAAG,IAAIjB,KAAK,CAACkB,KAAK,CAAC,CAAC;IAC/B,MAAMC,MAAM,GAAG,IAAInB,KAAK,CAACoB,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,EAAE,EAAE,CAAC;IAClED,MAAM,CAACE,QAAQ,CAACC,CAAC,GAAG,CAAC;;IAErB;IACA,MAAMC,QAAQ,GAAG,IAAIvB,KAAK,CAACwB,aAAa,CAAC;MACvCC,SAAS,EAAE,KAAK;MAAE;MAClBC,eAAe,EAAE,kBAAkB;MACnCC,OAAO,EAAE,KAAK;MACdC,KAAK,EAAE,KAAK;MACZC,KAAK,EAAE,IAAI;MACXC,SAAS,EAAE,MAAM,CAAC;IACpB,CAAC,CAAC;IAEFhB,WAAW,CAACE,OAAO,GAAGO,QAAQ;IAC9BA,QAAQ,CAACQ,OAAO,CAACC,MAAM,CAACC,UAAU,EAAED,MAAM,CAACE,WAAW,CAAC;;IAEvD;IACA,MAAMC,UAAU,GAAGC,IAAI,CAACC,GAAG,CAACL,MAAM,CAACM,gBAAgB,EAAE,GAAG,CAAC;IACzDf,QAAQ,CAACgB,aAAa,CAACJ,UAAU,CAAC;;IAElC;IACA,MAAMK,EAAE,GAAGjB,QAAQ,CAACkB,UAAU,CAAC,CAAC;IAChCD,EAAE,CAACE,YAAY,CAAC,0BAA0B,CAAC;IAC3CF,EAAE,CAACG,OAAO,CAACH,EAAE,CAACI,UAAU,CAAC;IACzBJ,EAAE,CAACG,OAAO,CAACH,EAAE,CAACK,KAAK,CAAC;IAEpBnC,YAAY,CAACM,OAAO,CAAC8B,WAAW,CAACvB,QAAQ,CAACwB,UAAU,CAAC;;IAErD;IACA,MAAMC,QAAQ,GAAG,IAAIhD,KAAK,CAACiD,cAAc,CAAC;MACxCC,QAAQ,EAAE;QACRC,IAAI,EAAE;UAAEC,KAAK,EAAE;QAAE;MACnB,CAAC;MACDC,YAAY,EAAE/C,kBAAkB;MAChCgD,cAAc,EAAE/C,oBAAoB;MACpCgD,WAAW,EAAE,KAAK;MAClBC,UAAU,EAAE,KAAK;MACjBC,SAAS,EAAE;IACb,CAAC,CAAC;IAEF,MAAMC,QAAQ,GAAG,IAAI1D,KAAK,CAAC2D,aAAa,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACpD,MAAMC,IAAI,GAAG,IAAI5D,KAAK,CAAC6D,IAAI,CAACH,QAAQ,EAAEV,QAAQ,CAAC;IAC/C/B,KAAK,CAAC6C,GAAG,CAACF,IAAI,CAAC;;IAEf;IACA,MAAMG,QAAQ,GAAG,IAAIC,oBAAoB,CACtCC,OAAO,IAAK;MACXlD,YAAY,CAACC,OAAO,GAAGiD,OAAO,CAAC,CAAC,CAAC,CAACC,cAAc;IAClD,CAAC,EACD;MAAEC,SAAS,EAAE;IAAE,CACjB,CAAC;IACDJ,QAAQ,CAACK,OAAO,CAAC1D,YAAY,CAACM,OAAO,CAAC;;IAEtC;IACA,IAAIqD,SAAS,GAAGC,WAAW,CAACC,GAAG,CAAC,CAAC;IACjC,MAAMC,SAAS,GAAG,EAAE;IACpB,MAAMC,aAAa,GAAG,IAAI,GAAGD,SAAS;IAEtC,MAAME,OAAO,GAAIC,SAAiB,IAAK;MACrC,IAAI,CAAC3B,QAAQ,IAAI,CAACzB,QAAQ,IAAI,CAACR,YAAY,CAACC,OAAO,EAAE;QACnDL,QAAQ,CAACK,OAAO,GAAG4D,qBAAqB,CAACF,OAAO,CAAC;QACjD;MACF;MAEA,MAAMG,KAAK,GAAGF,SAAS,GAAGN,SAAS;;MAEnC;MACA,IAAIQ,KAAK,GAAGJ,aAAa,EAAE;QACzB;QACA,MAAMK,aAAa,GAAG1C,IAAI,CAACC,GAAG,CAACwC,KAAK,GAAGJ,aAAa,EAAE,CAAC,CAAC;QACxD7D,OAAO,CAACI,OAAO,IAAI,KAAK,GAAG8D,aAAa,CAAC,CAAC;QAC1C9B,QAAQ,CAACE,QAAQ,CAACC,IAAI,CAACC,KAAK,GAAGxC,OAAO,CAACI,OAAO;QAE9CO,QAAQ,CAACwD,MAAM,CAAC9D,KAAK,EAAEE,MAAM,CAAC;QAC9BkD,SAAS,GAAGM,SAAS,GAAIE,KAAK,GAAGJ,aAAc;MACjD;MAEA9D,QAAQ,CAACK,OAAO,GAAG4D,qBAAqB,CAACF,OAAO,CAAC;IACnD,CAAC;IAED7D,WAAW,CAACG,OAAO,GAAGsD,WAAW,CAACC,GAAG,CAAC,CAAC;IACvC5D,QAAQ,CAACK,OAAO,GAAG4D,qBAAqB,CAACF,OAAO,CAAC;;IAEjD;IACA,IAAIM,aAAqB;IACzB,IAAIC,SAAS,GAAGjD,MAAM,CAACC,UAAU;IACjC,IAAIiD,UAAU,GAAGlD,MAAM,CAACE,WAAW;IAEnC,MAAMiD,YAAY,GAAGA,CAAA,KAAM;MACzB,IAAIH,aAAa,EAAE;QACjBI,oBAAoB,CAACJ,aAAa,CAAC;MACrC;MAEAA,aAAa,GAAGJ,qBAAqB,CAAC,MAAM;QAC1C,IAAI,CAACrD,QAAQ,EAAE;QAEf,MAAM8D,KAAK,GAAGrD,MAAM,CAACC,UAAU;QAC/B,MAAMqD,MAAM,GAAGtD,MAAM,CAACE,WAAW;QAEjC,IAAImD,KAAK,KAAKJ,SAAS,IAAIK,MAAM,KAAKJ,UAAU,EAAE;UAChD3D,QAAQ,CAACQ,OAAO,CAACsD,KAAK,EAAEC,MAAM,CAAC;UAC/BL,SAAS,GAAGI,KAAK;UACjBH,UAAU,GAAGI,MAAM;QACrB;MACF,CAAC,CAAC;IACJ,CAAC;IAEDtD,MAAM,CAACuD,gBAAgB,CAAC,QAAQ,EAAEJ,YAAY,EAAE;MAAEK,OAAO,EAAE;IAAK,CAAC,CAAC;IAElE,OAAO,MAAM;MAAA,IAAAC,qBAAA;MACX1B,QAAQ,CAAC2B,UAAU,CAAC,CAAC;MACrB,IAAI/E,QAAQ,CAACK,OAAO,EAAE;QACpBoE,oBAAoB,CAACzE,QAAQ,CAACK,OAAO,CAAC;MACxC;MACA,IAAIgE,aAAa,EAAE;QACjBI,oBAAoB,CAACJ,aAAa,CAAC;MACrC;MACAhD,MAAM,CAAC2D,mBAAmB,CAAC,QAAQ,EAAER,YAAY,CAAC;MAElD5D,QAAQ,CAACqE,OAAO,CAAC,CAAC;MAClBlC,QAAQ,CAACkC,OAAO,CAAC,CAAC;MAClB5C,QAAQ,CAAC4C,OAAO,CAAC,CAAC;MAElB,KAAAH,qBAAA,GAAI/E,YAAY,CAACM,OAAO,cAAAyE,qBAAA,eAApBA,qBAAA,CAAsBI,QAAQ,CAACtE,QAAQ,CAACwB,UAAU,CAAC,EAAE;QACvDrC,YAAY,CAACM,OAAO,CAAC8E,WAAW,CAACvE,QAAQ,CAACwB,UAAU,CAAC;MACvD;MAEAjC,WAAW,CAACE,OAAO,GAAG,IAAI;IAC5B,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,oBAAOd,OAAA,CAACC,mBAAmB;IAAC4F,GAAG,EAAErF;EAAa;IAAAsF,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC;AACnD,CAAC;AAAC1F,EAAA,CAjJWD,gBAA0B;AAAA4F,GAAA,GAA1B5F,gBAA0B;AAAA,IAAAH,EAAA,EAAA+F,GAAA;AAAAC,YAAA,CAAAhG,EAAA;AAAAgG,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}