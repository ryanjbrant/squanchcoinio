{"ast":null,"code":"var _jsxFileName = \"/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/CosmicVortex.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VortexContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: -1;\n  background: #000;\n`;\n\n// Aurora shader\n_c = VortexContainer;\nconst auroraVertexShader = `\n  varying vec2 vUv;\n  varying float vElevation;\n  uniform float time;\n\n  void main() {\n    vUv = uv;\n    \n    // Create flowing movement\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    float elevation = sin(modelPosition.x * 2.0 + time * 0.5) *\n                     sin(modelPosition.y * 2.0 + time * 0.3) * 0.2;\n    \n    modelPosition.z += elevation;\n    vElevation = elevation;\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n  }\n`;\nconst auroraFragmentShader = `\n  uniform float time;\n  uniform vec3 colorA;\n  uniform vec3 colorB;\n  uniform vec3 colorC;\n  varying vec2 vUv;\n  varying float vElevation;\n\n  void main() {\n    float mixStrength = (vElevation + 0.2) * 0.5;\n    \n    // Create swirling effect\n    vec2 swirl = vUv - 0.5;\n    float r = length(swirl) * 2.0;\n    float theta = atan(swirl.y, swirl.x);\n    float spiral = sin(r * 10.0 - time * 0.5 + theta * 2.0);\n    \n    // Mix colors based on position and time\n    vec3 color1 = mix(colorA, colorB, mixStrength);\n    vec3 color2 = mix(colorB, colorC, mixStrength);\n    vec3 finalColor = mix(color1, color2, spiral * 0.5 + 0.5);\n    \n    // Add transparency for ethereal effect\n    float alpha = smoothstep(0.0, 0.5, mixStrength) * 0.6;\n    \n    gl_FragColor = vec4(finalColor, alpha);\n  }\n`;\nexport const CosmicVortex = () => {\n  _s();\n  const containerRef = useRef(null);\n  const rendererRef = useRef(null);\n  const particlesRef = useRef(null);\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.z = 5;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      alpha: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Aurora planes\n    const createAuroraPlane = (position, rotation, colors) => {\n      const geometry = new THREE.PlaneGeometry(15, 15, 32, 32);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: auroraVertexShader,\n        fragmentShader: auroraFragmentShader,\n        uniforms: {\n          time: {\n            value: 0\n          },\n          colorA: {\n            value: new THREE.Color(colors[0])\n          },\n          colorB: {\n            value: new THREE.Color(colors[1])\n          },\n          colorC: {\n            value: new THREE.Color(colors[2])\n          }\n        },\n        transparent: true,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n        blending: THREE.AdditiveBlending\n      });\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.rotation.copy(rotation);\n      return mesh;\n    };\n\n    // Create multiple aurora planes with different colors and positions\n    const auroras = [createAuroraPlane(new THREE.Vector3(0, 0, -2), new THREE.Euler(0, 0, 0), ['#00ff88', '#0088ff', '#8800ff']), createAuroraPlane(new THREE.Vector3(0, 0, -1), new THREE.Euler(Math.PI * 0.25, 0, Math.PI * 0.1), ['#00ccff', '#ffcc00', '#00ffcc']), createAuroraPlane(new THREE.Vector3(0, 0, -3), new THREE.Euler(-Math.PI * 0.15, 0, -Math.PI * 0.1), ['#ffcc00', '#00ccff', '#cc00ff'])];\n    auroras.forEach(aurora => scene.add(aurora));\n\n    // Particles\n    const particlesGeometry = new THREE.BufferGeometry();\n    const particlesCount = 2000;\n    const positions = new Float32Array(particlesCount * 3);\n    const velocities = new Float32Array(particlesCount * 3);\n    const colors = new Float32Array(particlesCount * 3);\n    for (let i = 0; i < particlesCount; i++) {\n      const i3 = i * 3;\n      const radius = Math.random() * 10;\n      const theta = Math.random() * Math.PI * 2;\n      const phi = Math.random() * Math.PI;\n\n      // Position in spiral formation\n      positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n      positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n      positions[i3 + 2] = radius * Math.cos(phi);\n\n      // Velocity for swirling motion\n      velocities[i3] = (Math.random() - 0.5) * 0.01;\n      velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;\n      velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;\n\n      // Random colors between green, blue, and yellow\n      const colorChoice = Math.random();\n      if (colorChoice < 0.33) {\n        colors[i3] = 0.0; // Green\n        colors[i3 + 1] = 0.8 + Math.random() * 0.2;\n        colors[i3 + 2] = 0.0;\n      } else if (colorChoice < 0.66) {\n        colors[i3] = 0.0; // Blue\n        colors[i3 + 1] = 0.0;\n        colors[i3 + 2] = 0.8 + Math.random() * 0.2;\n      } else {\n        colors[i3] = 0.8 + Math.random() * 0.2; // Yellow\n        colors[i3 + 1] = 0.8 + Math.random() * 0.2;\n        colors[i3 + 2] = 0.0;\n      }\n    }\n    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n    const particlesMaterial = new THREE.PointsMaterial({\n      size: 0.05,\n      vertexColors: true,\n      transparent: true,\n      opacity: 0.8,\n      blending: THREE.AdditiveBlending\n    });\n    const particles = new THREE.Points(particlesGeometry, particlesMaterial);\n    particlesRef.current = particles;\n    scene.add(particles);\n\n    // Animation\n    let time = 0;\n    const animate = () => {\n      time += 0.001;\n\n      // Update aurora uniforms\n      auroras.forEach(aurora => {\n        const material = aurora.material;\n        material.uniforms.time.value = time;\n      });\n\n      // Update particle positions\n      const positions = particles.geometry.attributes.position.array;\n      for (let i = 0; i < particlesCount; i++) {\n        const i3 = i * 3;\n\n        // Create spiral motion\n        const x = positions[i3];\n        const y = positions[i3 + 1];\n        const z = positions[i3 + 2];\n        const radius = Math.sqrt(x * x + y * y + z * z);\n        const theta = Math.atan2(y, x) + 0.1 / radius;\n        const phi = Math.acos(z / radius);\n        positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n        positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n        positions[i3 + 2] = radius * Math.cos(phi);\n\n        // Slowly pull towards center\n        positions[i3] *= 0.9999;\n        positions[i3 + 1] *= 0.9999;\n        positions[i3 + 2] *= 0.9999;\n      }\n      particles.geometry.attributes.position.needsUpdate = true;\n\n      // Rotate camera slowly\n      camera.position.x = Math.sin(time * 0.1) * 5;\n      camera.position.z = Math.cos(time * 0.1) * 5;\n      camera.lookAt(0, 0, 0);\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    };\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n    window.addEventListener('resize', handleResize);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      renderer.dispose();\n      scene.traverse(object => {\n        if (object instanceof THREE.Mesh) {\n          object.geometry.dispose();\n          if (object.material instanceof THREE.Material) {\n            object.material.dispose();\n          }\n        }\n      });\n      if (containerRef.current && renderer.domElement) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(VortexContainer, {\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 258,\n    columnNumber: 10\n  }, this);\n};\n_s(CosmicVortex, \"3tpf8feKLzKlifjdysuB/LzJhkQ=\");\n_c2 = CosmicVortex;\nvar _c, _c2;\n$RefreshReg$(_c, \"VortexContainer\");\n$RefreshReg$(_c2, \"CosmicVortex\");","map":{"version":3,"names":["React","useEffect","useRef","styled","THREE","jsxDEV","_jsxDEV","VortexContainer","div","_c","auroraVertexShader","auroraFragmentShader","CosmicVortex","_s","containerRef","rendererRef","particlesRef","current","scene","Scene","camera","PerspectiveCamera","window","innerWidth","innerHeight","position","z","renderer","WebGLRenderer","antialias","alpha","setSize","setPixelRatio","Math","min","devicePixelRatio","appendChild","domElement","createAuroraPlane","rotation","colors","geometry","PlaneGeometry","material","ShaderMaterial","vertexShader","fragmentShader","uniforms","time","value","colorA","Color","colorB","colorC","transparent","depthWrite","side","DoubleSide","blending","AdditiveBlending","mesh","Mesh","copy","auroras","Vector3","Euler","PI","forEach","aurora","add","particlesGeometry","BufferGeometry","particlesCount","positions","Float32Array","velocities","i","i3","radius","random","theta","phi","sin","cos","colorChoice","setAttribute","BufferAttribute","particlesMaterial","PointsMaterial","size","vertexColors","opacity","particles","Points","animate","attributes","array","x","y","sqrt","atan2","acos","needsUpdate","lookAt","render","requestAnimationFrame","handleResize","aspect","updateProjectionMatrix","addEventListener","removeEventListener","dispose","traverse","object","Material","removeChild","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/CosmicVortex.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\n\nconst VortexContainer = styled.div`\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: -1;\n  background: #000;\n`;\n\n// Aurora shader\nconst auroraVertexShader = `\n  varying vec2 vUv;\n  varying float vElevation;\n  uniform float time;\n\n  void main() {\n    vUv = uv;\n    \n    // Create flowing movement\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    float elevation = sin(modelPosition.x * 2.0 + time * 0.5) *\n                     sin(modelPosition.y * 2.0 + time * 0.3) * 0.2;\n    \n    modelPosition.z += elevation;\n    vElevation = elevation;\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n  }\n`;\n\nconst auroraFragmentShader = `\n  uniform float time;\n  uniform vec3 colorA;\n  uniform vec3 colorB;\n  uniform vec3 colorC;\n  varying vec2 vUv;\n  varying float vElevation;\n\n  void main() {\n    float mixStrength = (vElevation + 0.2) * 0.5;\n    \n    // Create swirling effect\n    vec2 swirl = vUv - 0.5;\n    float r = length(swirl) * 2.0;\n    float theta = atan(swirl.y, swirl.x);\n    float spiral = sin(r * 10.0 - time * 0.5 + theta * 2.0);\n    \n    // Mix colors based on position and time\n    vec3 color1 = mix(colorA, colorB, mixStrength);\n    vec3 color2 = mix(colorB, colorC, mixStrength);\n    vec3 finalColor = mix(color1, color2, spiral * 0.5 + 0.5);\n    \n    // Add transparency for ethereal effect\n    float alpha = smoothstep(0.0, 0.5, mixStrength) * 0.6;\n    \n    gl_FragColor = vec4(finalColor, alpha);\n  }\n`;\n\nexport const CosmicVortex: React.FC = () => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const particlesRef = useRef<THREE.Points | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.z = 5;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Aurora planes\n    const createAuroraPlane = (position: THREE.Vector3, rotation: THREE.Euler, colors: [string, string, string]) => {\n      const geometry = new THREE.PlaneGeometry(15, 15, 32, 32);\n      const material = new THREE.ShaderMaterial({\n        vertexShader: auroraVertexShader,\n        fragmentShader: auroraFragmentShader,\n        uniforms: {\n          time: { value: 0 },\n          colorA: { value: new THREE.Color(colors[0]) },\n          colorB: { value: new THREE.Color(colors[1]) },\n          colorC: { value: new THREE.Color(colors[2]) }\n        },\n        transparent: true,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n        blending: THREE.AdditiveBlending\n      });\n\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.copy(position);\n      mesh.rotation.copy(rotation);\n      return mesh;\n    };\n\n    // Create multiple aurora planes with different colors and positions\n    const auroras = [\n      createAuroraPlane(\n        new THREE.Vector3(0, 0, -2),\n        new THREE.Euler(0, 0, 0),\n        ['#00ff88', '#0088ff', '#8800ff']\n      ),\n      createAuroraPlane(\n        new THREE.Vector3(0, 0, -1),\n        new THREE.Euler(Math.PI * 0.25, 0, Math.PI * 0.1),\n        ['#00ccff', '#ffcc00', '#00ffcc']\n      ),\n      createAuroraPlane(\n        new THREE.Vector3(0, 0, -3),\n        new THREE.Euler(-Math.PI * 0.15, 0, -Math.PI * 0.1),\n        ['#ffcc00', '#00ccff', '#cc00ff']\n      )\n    ];\n\n    auroras.forEach(aurora => scene.add(aurora));\n\n    // Particles\n    const particlesGeometry = new THREE.BufferGeometry();\n    const particlesCount = 2000;\n    const positions = new Float32Array(particlesCount * 3);\n    const velocities = new Float32Array(particlesCount * 3);\n    const colors = new Float32Array(particlesCount * 3);\n\n    for (let i = 0; i < particlesCount; i++) {\n      const i3 = i * 3;\n      const radius = Math.random() * 10;\n      const theta = Math.random() * Math.PI * 2;\n      const phi = Math.random() * Math.PI;\n\n      // Position in spiral formation\n      positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n      positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n      positions[i3 + 2] = radius * Math.cos(phi);\n\n      // Velocity for swirling motion\n      velocities[i3] = (Math.random() - 0.5) * 0.01;\n      velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;\n      velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;\n\n      // Random colors between green, blue, and yellow\n      const colorChoice = Math.random();\n      if (colorChoice < 0.33) {\n        colors[i3] = 0.0; // Green\n        colors[i3 + 1] = 0.8 + Math.random() * 0.2;\n        colors[i3 + 2] = 0.0;\n      } else if (colorChoice < 0.66) {\n        colors[i3] = 0.0; // Blue\n        colors[i3 + 1] = 0.0;\n        colors[i3 + 2] = 0.8 + Math.random() * 0.2;\n      } else {\n        colors[i3] = 0.8 + Math.random() * 0.2; // Yellow\n        colors[i3 + 1] = 0.8 + Math.random() * 0.2;\n        colors[i3 + 2] = 0.0;\n      }\n    }\n\n    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n    const particlesMaterial = new THREE.PointsMaterial({\n      size: 0.05,\n      vertexColors: true,\n      transparent: true,\n      opacity: 0.8,\n      blending: THREE.AdditiveBlending\n    });\n\n    const particles = new THREE.Points(particlesGeometry, particlesMaterial);\n    particlesRef.current = particles;\n    scene.add(particles);\n\n    // Animation\n    let time = 0;\n    const animate = () => {\n      time += 0.001;\n\n      // Update aurora uniforms\n      auroras.forEach(aurora => {\n        const material = aurora.material as THREE.ShaderMaterial;\n        material.uniforms.time.value = time;\n      });\n\n      // Update particle positions\n      const positions = particles.geometry.attributes.position.array as Float32Array;\n      for (let i = 0; i < particlesCount; i++) {\n        const i3 = i * 3;\n        \n        // Create spiral motion\n        const x = positions[i3];\n        const y = positions[i3 + 1];\n        const z = positions[i3 + 2];\n        \n        const radius = Math.sqrt(x * x + y * y + z * z);\n        const theta = Math.atan2(y, x) + (0.1 / radius);\n        const phi = Math.acos(z / radius);\n        \n        positions[i3] = radius * Math.sin(phi) * Math.cos(theta);\n        positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n        positions[i3 + 2] = radius * Math.cos(phi);\n        \n        // Slowly pull towards center\n        positions[i3] *= 0.9999;\n        positions[i3 + 1] *= 0.9999;\n        positions[i3 + 2] *= 0.9999;\n      }\n      particles.geometry.attributes.position.needsUpdate = true;\n\n      // Rotate camera slowly\n      camera.position.x = Math.sin(time * 0.1) * 5;\n      camera.position.z = Math.cos(time * 0.1) * 5;\n      camera.lookAt(0, 0, 0);\n\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    };\n\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      renderer.dispose();\n      scene.traverse((object) => {\n        if (object instanceof THREE.Mesh) {\n          object.geometry.dispose();\n          if (object.material instanceof THREE.Material) {\n            object.material.dispose();\n          }\n        }\n      });\n      if (containerRef.current && renderer.domElement) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n\n  return <VortexContainer ref={containerRef} />;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}