{"ast":null,"code":"var _jsxFileName = \"/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/PortalBackground.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Canvas = styled.canvas`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 0;\n`;\n_c = Canvas;\nconst portalVertexShader = `\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  \n  void main() {\n    vUv = uv;\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\nconst portalFragmentShader = `\n  uniform float time;\n  uniform vec2 mousePos;\n  uniform vec2 mouseVelocity;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n\n  #define PI 3.14159265359\n\n  // Noise functions\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n  float snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n      + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n  }\n\n  float fbm(vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    // Reduced octaves for simpler effect\n    for(int i = 0; i < 4; i++) {\n      sum += amp * snoise(p * freq);\n      freq *= 2.0;\n      amp *= 0.75;\n      p = p * 1.2 + vec2(3.2);\n    }\n    return sum;\n  }\n\n  // Star field function\n  float star(vec2 uv, float flare) {\n    float d = length(uv);\n    float m = 0.001/d;  // Reduced from 0.002 for smaller stars\n    return smoothstep(0.9, 1.0, m);  // Removed glow and flare effects\n  }\n\n  vec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n  }\n\n  vec3 purpleToRed(vec3 purple, float influence) {\n    vec3 red = vec3(0.9, 0.1, 0.8);\n    // Create inward flowing red effect\n    float flowFactor = smoothstep(0.5, 0.0, length(vUv - vec2(0.5)));\n    return mix(purple, red, influence * flowFactor);\n  }\n\n  float ripple(vec2 uv, vec2 center, float time, float frequency, float speed) {\n    float d = length(uv - center);\n    // Add inward flow to ripples\n    float inwardFlow = (1.0 - d) * 2.0;\n    float ripple = sin(d * frequency - time * speed + inwardFlow);\n    float fadeOut = smoothstep(1.0, 0.0, d); // Tighter radius\n    return fadeOut * ripple;\n  }\n\n  void main() {\n    vec2 center = vec2(0.5, 0.5);\n    vec2 p = vUv - center;\n    \n    // Calculate distance to mouse and center\n    float mouseDist = length(vUv - mousePos);\n    float centerDist = length(p);\n    float mouseInfluence = smoothstep(0.12, 0.0, mouseDist); // Even smaller radius\n    \n    // Create inward-flowing ripple effect\n    float rippleEffect = ripple(vUv, mousePos, time * 5.0, 40.0, 5.0);\n    rippleEffect += ripple(vUv, mousePos, time * 4.0, 30.0, 4.0) * 0.5;\n    rippleEffect += ripple(vUv, mousePos, time * 3.0, 20.0, 3.0) * 0.25;\n    \n    // Create inward flow direction\n    vec2 toCenter = normalize(-p);\n    float flowStrength = smoothstep(1.0, 0.0, centerDist);\n    \n    // Apply ripple distortion with inward flow\n    vec2 distortion = vec2(rippleEffect) * mouseInfluence * 0.02;\n    distortion += toCenter * mouseInfluence * flowStrength * 0.03; // Add inward pull\n    p += distortion;\n    \n    float r = length(p);\n    float angle = atan(p.y, p.x);\n\n    // Add flow-based turbulence\n    float turbulence = mouseInfluence * rippleEffect * flowStrength * 0.02;\n    r += turbulence;\n\n    // Create seamless spiral effect\n    float t = time * 0.1;\n    float spiral = angle / (2.0 * PI) + log(r) * 0.5;\n    spiral = fract(spiral * 1. - t + mouseInfluence * flowStrength * 0.1);\n\n    // Create seamless noise with inward flow\n    vec2 rotatedUv = vec2(cos(t) * p.x - sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n    rotatedUv += distortion * 0.5;\n    \n    float noise1 = fbm(vec2(r * 2.0 + t, spiral * 3.0));\n    float noise2 = fbm(vec2(r * 4.5 - t * 0.5, spiral * 2.0));\n\n    // Enhanced spiral flow\n    float flow = smoothstep(0.0, 0.8, spiral) * smoothstep(1.0, 5.2, spiral);\n    flow += mouseInfluence * rippleEffect * flowStrength * 0.2;\n    \n    // Energy effect with inward color flow\n    float energy = flow + noise1 * 0.9;\n    energy *= smoothstep(0.0, 0.2, r);\n    energy *= smoothstep(1.0, 0.3, r);\n    energy += mouseInfluence * rippleEffect * flowStrength * 0.3;\n\n    // Color palette with inward-flowing red\n    vec3 darkVoid = vec3(0.0, 0.0, 0.0);\n    vec3 baseColor1 = vec3(0.6, 0.0, 0.9);\n    vec3 baseColor2 = vec3(0.4, 0.0, 0.7);\n    \n    // Create red influence that flows inward\n    float redInfluence = mouseInfluence * rippleEffect * smoothstep(1.0, 0.0, centerDist);\n    vec3 energyColor1 = purpleToRed(baseColor1, redInfluence);\n    vec3 energyColor2 = purpleToRed(baseColor2, redInfluence * 0.8);\n\n    // Create base spiral structure\n    float spiralIntensity = smoothstep(0.2, 0.8, energy);\n    vec3 finalColor = mix(darkVoid, energyColor1, spiralIntensity * (2.0 - r));\n\n    // Add layered energy effects\n    float energyMix1 = (noise1 * 0.5 + redInfluence * 0.3) * (1.0 - r);\n    float energyMix2 = (noise2 * 0.3 + redInfluence * 0.2) * (1.0 - r);\n\n    finalColor = mix(finalColor, energyColor1, energyMix1);\n    finalColor = mix(finalColor, energyColor2, energyMix2);\n\n    // Add smaller stars\n    float starTime = -time * 0.5;\n    float starLayer1 = 0.0;\n    float starLayer2 = 0.0;\n    \n    // Create multiple star layers\n    for(int i = 0; i < 35; i++) {\n      float fi = float(i);\n      float t = starTime * (5.0 + fi * 0.1) + fi * 1.23;\n      float scale = 0.2 + fi * 0.05;\n      \n      // Star position with spiral motion\n      float radius = fract(t * 0.1 + fi * 0.123) * 1.2;\n      float angle = -t * 0.5 + fi * 1.57;\n      vec2 xy = vec2(cos(angle), sin(angle)) * radius;\n      \n      vec2 starPos = rotate(xy, -t * 0.2);\n      starPos = starPos * scale;\n      \n      float starIntensity = star(p - starPos, 0.15) * 10.0;\n      \n      float fadeOut = smoothstep(0.0, 0.1, length(starPos));\n      float fadeIn = smoothstep(1.0, 0.3, length(starPos));\n      \n      starLayer1 += starIntensity * fadeOut * fadeIn * 0.3;\n    }\n    \n    // Second star layer with different timing\n    for(int i = 0; i < 25; i++) {\n      float fi = float(i);\n      float t = starTime * (0.8 + fi * 0.1) + fi * 2.34;\n      float scale = 0.15 + fi * 0.03;\n      \n      float radius = fract(t * 0.15 + fi * 0.234) * 1.0;\n      float angle = -t * 0.7 + fi * 2.12;\n      vec2 xy = vec2(cos(angle), sin(angle)) * radius;\n      \n      vec2 starPos = rotate(xy, -t * 0.25);\n      starPos = starPos * scale;\n      \n      float starIntensity = star(p - starPos, 0.1) * 5.5;\n      float fadeOut = smoothstep(0.0, 0.15, length(starPos));\n      float fadeIn = smoothstep(1.0, 0.4, length(starPos));\n      \n      starLayer2 += starIntensity * fadeOut * fadeIn * 0.25;\n    }\n\n    // Add stars with reduced intensity\n    vec3 starColor1 = vec3(1.0, 0.95, 1.0);\n    vec3 starColor2 = vec3(0.9, 0.85, 1.0);\n    \n    finalColor += starColor1 * starLayer1;  // Removed multiplier for less intensity\n    finalColor += starColor2 * starLayer2 * 0.8;  // Reduced from 1.2 to 0.8\n\n    // Enhance the void effect\n    float voidStrength = smoothstep(0.15, 0.0, r);\n    finalColor = mix(finalColor, darkVoid, voidStrength);\n\n    gl_FragColor = vec4(finalColor, 1.0);\n  }\n`;\nexport const PortalBackground = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const rendererRef = useRef(null);\n  const sceneRef = useRef(null);\n  const cameraRef = useRef(null);\n  const timeRef = useRef(0);\n  const frameRef = useRef(0);\n  const lastTimeRef = useRef(0);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    // Initialize renderer\n    const renderer = new THREE.WebGLRenderer({\n      canvas,\n      alpha: true,\n      antialias: true,\n      powerPreference: 'high-performance',\n      stencil: false,\n      depth: false\n    });\n    renderer.setPixelRatio(window.devicePixelRatio);\n    rendererRef.current = renderer;\n\n    // Initialize scene and camera\n    const scene = new THREE.Scene();\n    sceneRef.current = scene;\n    const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);\n    camera.position.z = 1;\n    cameraRef.current = camera;\n\n    // Create and add portal mesh\n    const geometry = new THREE.PlaneGeometry(2, 2);\n    const material = new THREE.ShaderMaterial({\n      uniforms: {\n        time: {\n          value: 0\n        },\n        resolution: {\n          value: new THREE.Vector2()\n        }\n      },\n      vertexShader: portalVertexShader,\n      fragmentShader: portalFragmentShader,\n      depthWrite: false\n    });\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    // Handle resize\n    const handleResize = () => {\n      const container = canvas.parentElement;\n      if (!container) return;\n      const {\n        width,\n        height\n      } = container.getBoundingClientRect();\n      renderer.setSize(width, height, false);\n      camera.aspect = width / height;\n      camera.updateProjectionMatrix();\n      material.uniforms.resolution.value.set(width, height);\n    };\n\n    // Initial size\n    handleResize();\n\n    // Add resize listener\n    const resizeObserver = new ResizeObserver(handleResize);\n    if (canvas.parentElement) {\n      resizeObserver.observe(canvas.parentElement);\n    }\n\n    // Animation loop\n    const animate = currentTime => {\n      if (!lastTimeRef.current) lastTimeRef.current = currentTime;\n      const deltaTime = (currentTime - lastTimeRef.current) * 0.001; // Convert to seconds\n      lastTimeRef.current = currentTime;\n      timeRef.current += deltaTime * 0.5; // Adjust speed here\n      material.uniforms.time.value = timeRef.current;\n      renderer.render(scene, camera);\n      frameRef.current = requestAnimationFrame(animate);\n    };\n    frameRef.current = requestAnimationFrame(animate);\n    return () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n      resizeObserver.disconnect();\n      renderer.dispose();\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(Canvas, {\n    ref: canvasRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 338,\n    columnNumber: 10\n  }, this);\n};\n_s(PortalBackground, \"FlLoM4lUF+NwS9WErIwkXpIPEzs=\");\n_c2 = PortalBackground;\nvar _c, _c2;\n$RefreshReg$(_c, \"Canvas\");\n$RefreshReg$(_c2, \"PortalBackground\");","map":{"version":3,"names":["React","useEffect","useRef","styled","THREE","jsxDEV","_jsxDEV","Canvas","canvas","_c","portalVertexShader","portalFragmentShader","PortalBackground","_s","canvasRef","rendererRef","sceneRef","cameraRef","timeRef","frameRef","lastTimeRef","current","renderer","WebGLRenderer","alpha","antialias","powerPreference","stencil","depth","setPixelRatio","window","devicePixelRatio","scene","Scene","camera","PerspectiveCamera","clientWidth","clientHeight","position","z","geometry","PlaneGeometry","material","ShaderMaterial","uniforms","time","value","resolution","Vector2","vertexShader","fragmentShader","depthWrite","mesh","Mesh","add","handleResize","container","parentElement","width","height","getBoundingClientRect","setSize","aspect","updateProjectionMatrix","set","resizeObserver","ResizeObserver","observe","animate","currentTime","deltaTime","render","requestAnimationFrame","cancelAnimationFrame","disconnect","dispose","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ryan/H3M Dropbox/Ryan Brant/repos/squanchcoin/src/components/PortalBackground.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport * as THREE from 'three';\n\nconst Canvas = styled.canvas`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 0;\n`;\n\nconst portalVertexShader = `\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  \n  void main() {\n    vUv = uv;\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\nconst portalFragmentShader = `\n  uniform float time;\n  uniform vec2 mousePos;\n  uniform vec2 mouseVelocity;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n\n  #define PI 3.14159265359\n\n  // Noise functions\n  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n  vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n  float snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n      + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n  }\n\n  float fbm(vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    // Reduced octaves for simpler effect\n    for(int i = 0; i < 4; i++) {\n      sum += amp * snoise(p * freq);\n      freq *= 2.0;\n      amp *= 0.75;\n      p = p * 1.2 + vec2(3.2);\n    }\n    return sum;\n  }\n\n  // Star field function\n  float star(vec2 uv, float flare) {\n    float d = length(uv);\n    float m = 0.001/d;  // Reduced from 0.002 for smaller stars\n    return smoothstep(0.9, 1.0, m);  // Removed glow and flare effects\n  }\n\n  vec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n  }\n\n  vec3 purpleToRed(vec3 purple, float influence) {\n    vec3 red = vec3(0.9, 0.1, 0.8);\n    // Create inward flowing red effect\n    float flowFactor = smoothstep(0.5, 0.0, length(vUv - vec2(0.5)));\n    return mix(purple, red, influence * flowFactor);\n  }\n\n  float ripple(vec2 uv, vec2 center, float time, float frequency, float speed) {\n    float d = length(uv - center);\n    // Add inward flow to ripples\n    float inwardFlow = (1.0 - d) * 2.0;\n    float ripple = sin(d * frequency - time * speed + inwardFlow);\n    float fadeOut = smoothstep(1.0, 0.0, d); // Tighter radius\n    return fadeOut * ripple;\n  }\n\n  void main() {\n    vec2 center = vec2(0.5, 0.5);\n    vec2 p = vUv - center;\n    \n    // Calculate distance to mouse and center\n    float mouseDist = length(vUv - mousePos);\n    float centerDist = length(p);\n    float mouseInfluence = smoothstep(0.12, 0.0, mouseDist); // Even smaller radius\n    \n    // Create inward-flowing ripple effect\n    float rippleEffect = ripple(vUv, mousePos, time * 5.0, 40.0, 5.0);\n    rippleEffect += ripple(vUv, mousePos, time * 4.0, 30.0, 4.0) * 0.5;\n    rippleEffect += ripple(vUv, mousePos, time * 3.0, 20.0, 3.0) * 0.25;\n    \n    // Create inward flow direction\n    vec2 toCenter = normalize(-p);\n    float flowStrength = smoothstep(1.0, 0.0, centerDist);\n    \n    // Apply ripple distortion with inward flow\n    vec2 distortion = vec2(rippleEffect) * mouseInfluence * 0.02;\n    distortion += toCenter * mouseInfluence * flowStrength * 0.03; // Add inward pull\n    p += distortion;\n    \n    float r = length(p);\n    float angle = atan(p.y, p.x);\n\n    // Add flow-based turbulence\n    float turbulence = mouseInfluence * rippleEffect * flowStrength * 0.02;\n    r += turbulence;\n\n    // Create seamless spiral effect\n    float t = time * 0.1;\n    float spiral = angle / (2.0 * PI) + log(r) * 0.5;\n    spiral = fract(spiral * 1. - t + mouseInfluence * flowStrength * 0.1);\n\n    // Create seamless noise with inward flow\n    vec2 rotatedUv = vec2(cos(t) * p.x - sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n    rotatedUv += distortion * 0.5;\n    \n    float noise1 = fbm(vec2(r * 2.0 + t, spiral * 3.0));\n    float noise2 = fbm(vec2(r * 4.5 - t * 0.5, spiral * 2.0));\n\n    // Enhanced spiral flow\n    float flow = smoothstep(0.0, 0.8, spiral) * smoothstep(1.0, 5.2, spiral);\n    flow += mouseInfluence * rippleEffect * flowStrength * 0.2;\n    \n    // Energy effect with inward color flow\n    float energy = flow + noise1 * 0.9;\n    energy *= smoothstep(0.0, 0.2, r);\n    energy *= smoothstep(1.0, 0.3, r);\n    energy += mouseInfluence * rippleEffect * flowStrength * 0.3;\n\n    // Color palette with inward-flowing red\n    vec3 darkVoid = vec3(0.0, 0.0, 0.0);\n    vec3 baseColor1 = vec3(0.6, 0.0, 0.9);\n    vec3 baseColor2 = vec3(0.4, 0.0, 0.7);\n    \n    // Create red influence that flows inward\n    float redInfluence = mouseInfluence * rippleEffect * smoothstep(1.0, 0.0, centerDist);\n    vec3 energyColor1 = purpleToRed(baseColor1, redInfluence);\n    vec3 energyColor2 = purpleToRed(baseColor2, redInfluence * 0.8);\n\n    // Create base spiral structure\n    float spiralIntensity = smoothstep(0.2, 0.8, energy);\n    vec3 finalColor = mix(darkVoid, energyColor1, spiralIntensity * (2.0 - r));\n\n    // Add layered energy effects\n    float energyMix1 = (noise1 * 0.5 + redInfluence * 0.3) * (1.0 - r);\n    float energyMix2 = (noise2 * 0.3 + redInfluence * 0.2) * (1.0 - r);\n\n    finalColor = mix(finalColor, energyColor1, energyMix1);\n    finalColor = mix(finalColor, energyColor2, energyMix2);\n\n    // Add smaller stars\n    float starTime = -time * 0.5;\n    float starLayer1 = 0.0;\n    float starLayer2 = 0.0;\n    \n    // Create multiple star layers\n    for(int i = 0; i < 35; i++) {\n      float fi = float(i);\n      float t = starTime * (5.0 + fi * 0.1) + fi * 1.23;\n      float scale = 0.2 + fi * 0.05;\n      \n      // Star position with spiral motion\n      float radius = fract(t * 0.1 + fi * 0.123) * 1.2;\n      float angle = -t * 0.5 + fi * 1.57;\n      vec2 xy = vec2(cos(angle), sin(angle)) * radius;\n      \n      vec2 starPos = rotate(xy, -t * 0.2);\n      starPos = starPos * scale;\n      \n      float starIntensity = star(p - starPos, 0.15) * 10.0;\n      \n      float fadeOut = smoothstep(0.0, 0.1, length(starPos));\n      float fadeIn = smoothstep(1.0, 0.3, length(starPos));\n      \n      starLayer1 += starIntensity * fadeOut * fadeIn * 0.3;\n    }\n    \n    // Second star layer with different timing\n    for(int i = 0; i < 25; i++) {\n      float fi = float(i);\n      float t = starTime * (0.8 + fi * 0.1) + fi * 2.34;\n      float scale = 0.15 + fi * 0.03;\n      \n      float radius = fract(t * 0.15 + fi * 0.234) * 1.0;\n      float angle = -t * 0.7 + fi * 2.12;\n      vec2 xy = vec2(cos(angle), sin(angle)) * radius;\n      \n      vec2 starPos = rotate(xy, -t * 0.25);\n      starPos = starPos * scale;\n      \n      float starIntensity = star(p - starPos, 0.1) * 5.5;\n      float fadeOut = smoothstep(0.0, 0.15, length(starPos));\n      float fadeIn = smoothstep(1.0, 0.4, length(starPos));\n      \n      starLayer2 += starIntensity * fadeOut * fadeIn * 0.25;\n    }\n\n    // Add stars with reduced intensity\n    vec3 starColor1 = vec3(1.0, 0.95, 1.0);\n    vec3 starColor2 = vec3(0.9, 0.85, 1.0);\n    \n    finalColor += starColor1 * starLayer1;  // Removed multiplier for less intensity\n    finalColor += starColor2 * starLayer2 * 0.8;  // Reduced from 1.2 to 0.8\n\n    // Enhance the void effect\n    float voidStrength = smoothstep(0.15, 0.0, r);\n    finalColor = mix(finalColor, darkVoid, voidStrength);\n\n    gl_FragColor = vec4(finalColor, 1.0);\n  }\n`;\n\nexport const PortalBackground: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const sceneRef = useRef<THREE.Scene | null>(null);\n  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);\n  const timeRef = useRef<number>(0);\n  const frameRef = useRef<number>(0);\n  const lastTimeRef = useRef<number>(0);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    // Initialize renderer\n    const renderer = new THREE.WebGLRenderer({\n      canvas,\n      alpha: true,\n      antialias: true,\n      powerPreference: 'high-performance',\n      stencil: false,\n      depth: false\n    });\n    renderer.setPixelRatio(window.devicePixelRatio);\n    rendererRef.current = renderer;\n\n    // Initialize scene and camera\n    const scene = new THREE.Scene();\n    sceneRef.current = scene;\n\n    const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);\n    camera.position.z = 1;\n    cameraRef.current = camera;\n\n    // Create and add portal mesh\n    const geometry = new THREE.PlaneGeometry(2, 2);\n    const material = new THREE.ShaderMaterial({\n      uniforms: {\n        time: { value: 0 },\n        resolution: { value: new THREE.Vector2() }\n      },\n      vertexShader: portalVertexShader,\n      fragmentShader: portalFragmentShader,\n      depthWrite: false\n    });\n\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    // Handle resize\n    const handleResize = () => {\n      const container = canvas.parentElement;\n      if (!container) return;\n\n      const { width, height } = container.getBoundingClientRect();\n      renderer.setSize(width, height, false);\n      camera.aspect = width / height;\n      camera.updateProjectionMatrix();\n      material.uniforms.resolution.value.set(width, height);\n    };\n\n    // Initial size\n    handleResize();\n\n    // Add resize listener\n    const resizeObserver = new ResizeObserver(handleResize);\n    if (canvas.parentElement) {\n      resizeObserver.observe(canvas.parentElement);\n    }\n\n    // Animation loop\n    const animate = (currentTime: number) => {\n      if (!lastTimeRef.current) lastTimeRef.current = currentTime;\n      const deltaTime = (currentTime - lastTimeRef.current) * 0.001; // Convert to seconds\n      lastTimeRef.current = currentTime;\n\n      timeRef.current += deltaTime * 0.5; // Adjust speed here\n      material.uniforms.time.value = timeRef.current;\n\n      renderer.render(scene, camera);\n      frameRef.current = requestAnimationFrame(animate);\n    };\n\n    frameRef.current = requestAnimationFrame(animate);\n\n    return () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n      resizeObserver.disconnect();\n      renderer.dispose();\n    };\n  }, []);\n\n  return <Canvas ref={canvasRef} />;\n}; "],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAO,KAAKC,KAAK,MAAM,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE/B,MAAMC,MAAM,GAAGJ,MAAM,CAACK,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAACC,EAAA,GAPIF,MAAM;AASZ,MAAMG,kBAAkB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,oBAAoB,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}